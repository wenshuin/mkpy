

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mkpy.mkh5 &mdash; mkpy 0.1.3 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> mkpy
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">Introduction</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Quick Start.html">Quick start</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Pygarv.html">pygarv: EEG visualization dashboard</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../User Files.html">User input files</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Output Files.html">EEG data files</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Learning.html">Background reading</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Glossary.html">Glossary</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Reference.html">Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../RolesCredits.html">Roles and credits</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">mkpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../mkpy.html">mkpy</a> &raquo;</li>
        
      <li>mkpy.mkh5</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mkpy.mkh5</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="k">import</span> <span class="n">Path</span>

<span class="c1"># import dpath.util</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">dpath</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">mkpy</span> <span class="k">import</span> <span class="n">mkio</span><span class="p">,</span> <span class="n">pygarv</span><span class="p">,</span> <span class="n">h5tools</span>
<span class="kn">from</span> <span class="nn">mkpy.codetagger</span> <span class="k">import</span> <span class="n">CodeTagger</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">current_function</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="n">log_exceptions</span>
<span class="kn">from</span> <span class="nn">.__version__</span> <span class="k">import</span> <span class="n">__version__</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Entering &quot;</span> <span class="o">+</span> <span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># FIX ME: do something w/ custom exceptions</span>
<div class="viewcode-block" id="BadChannelsError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.BadChannelsError">[docs]</a><span class="k">class</span> <span class="nc">BadChannelsError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>  <span class="c1"># from NJS, deprecated</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="BadCalibrateCallError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.BadCalibrateCallError">[docs]</a><span class="k">class</span> <span class="nc">BadCalibrateCallError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="DuplicateLocationLabelError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.DuplicateLocationLabelError">[docs]</a><span class="k">class</span> <span class="nc">DuplicateLocationLabelError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="MightyWeenieCals"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.MightyWeenieCals">[docs]</a><span class="k">class</span> <span class="nc">MightyWeenieCals</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="EpochSpansBoundary"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.EpochSpansBoundary">[docs]</a><span class="k">class</span> <span class="nc">EpochSpansBoundary</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="LogRawEventCodeMismatch"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.LogRawEventCodeMismatch">[docs]</a><span class="k">class</span> <span class="nc">LogRawEventCodeMismatch</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="DigRecordsNotSequential"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.DigRecordsNotSequential">[docs]</a><span class="k">class</span> <span class="nc">DigRecordsNotSequential</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="mkh5"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5">[docs]</a><span class="k">class</span> <span class="nc">mkh5</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Import and prepare ERPSS single-trial data for cross-platform analysis.</span>

<span class="sd">    This class provides the user API for converting compressed binary</span>
<span class="sd">    EEG data files into readily accessible HDF5 files.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h5_fname : str</span>
<span class="sd">        Path to a new or existing HDF5 file used as the database.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># BEGIN DEPRECATED dtypes</span>
    <span class="c1"># _utc = &#39;u4&#39; # stub for time stamp in microseconds</span>
    <span class="c1"># _bin_num = &#39;u4&#39; # 0-base numeric bin index from blf</span>
    <span class="c1"># END DEPRECATED dtypes</span>
    <span class="c1"># _chan_num = &#39;u4&#39; # 0-base numeric channel index from dig header</span>
    <span class="c1"># _mkAD = &#39;i2&#39; # kutaslab AD samples are int16</span>
    <span class="c1"># _art_flag = &#39;u2&#39; # bit mask for bad channels 0 = good, 1 = bad</span>

    <span class="c1"># numpy dtypes for the data coming from dig .crw/.raw</span>
    <span class="n">_evtick</span> <span class="o">=</span> <span class="s2">&quot;u4&quot;</span>  <span class="c1"># dig crw sample counter, mis-named clk_tick in log2asci</span>
    <span class="n">_evcode</span> <span class="o">=</span> <span class="s2">&quot;i2&quot;</span>  <span class="c1"># numeric event codes from dig marktrack *AND* log</span>
    <span class="n">_log_ccode</span> <span class="o">=</span> <span class="s2">&quot;u2&quot;</span>  <span class="c1"># numeric condition code from log</span>
    <span class="n">_log_flag</span> <span class="o">=</span> <span class="s2">&quot;u2&quot;</span>  <span class="c1"># numeric condition code from log</span>
    <span class="n">_mk_EEG</span> <span class="o">=</span> <span class="s2">&quot;f2&quot;</span>  <span class="c1"># kutaslab 12-bit AD or 16 bits after calibrating</span>
    <span class="n">_epoch_t</span> <span class="o">=</span> <span class="s2">&quot;i8&quot;</span>  <span class="c1"># positive and negative samples for interval data</span>
    <span class="n">_pygarv</span> <span class="o">=</span> <span class="s2">&quot;uint64&quot;</span>  <span class="c1"># 64-bit column to track up to 64 pygarv data tests</span>

    <span class="c1"># white list of dig raw (*NOT LOG*) event codes for</span>
    <span class="c1"># splitting the .raw/.crw into mkh5 dblocks</span>
    <span class="n">_dig_pause_marks</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">16384</span><span class="p">,)</span>

<div class="viewcode-block" id="mkh5.Mkh5Error"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.Mkh5Error">[docs]</a>    <span class="k">class</span> <span class="nc">Mkh5Error</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;general purposes mkh5 error&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.Mkh5CalError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.Mkh5CalError">[docs]</a>    <span class="k">class</span> <span class="nc">Mkh5CalError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;mkh5 calibration error&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.Mkh5FormatError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.Mkh5FormatError">[docs]</a>    <span class="k">class</span> <span class="nc">Mkh5FormatError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;raised on mkh5 format violations&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.YamlHeaderFormatError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.YamlHeaderFormatError">[docs]</a>    <span class="k">class</span> <span class="nc">YamlHeaderFormatError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;informative errors for bad yhdr YAML files&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.EpochsTableDataError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.EpochsTableDataError">[docs]</a>    <span class="k">class</span> <span class="nc">EpochsTableDataError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;raised for pd.Series data we can&#39;t or won&#39;t directly convert for HDF5</span>

<span class="sd">        These include mixed num-like and str-like * booleans with missing data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pd_data_type</span><span class="p">,</span> <span class="n">series</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">series</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;un_named_series&quot;</span>
            <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">pandas.Series &quot;</span> <span class="o">+</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> data type&quot;</span>
                    <span class="s2">&quot; with missing data/NaN not supported for &quot;</span>
                    <span class="s2">&quot; epochs tables&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pd_data_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">pandas.Series &quot;</span>
                    <span class="o">+</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span>
                    <span class="o">+</span> <span class="s2">&quot; </span><span class="si">{0}</span><span class="s2"> data type not supported for&quot;</span>
                    <span class="s2">&quot; epochs tables&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pd_data_type</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.HeaderIO"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO">[docs]</a>    <span class="k">class</span> <span class="nc">HeaderIO</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;private-ish helper class for managing mkh5 datablock header information</span>

<span class="sd">        mkh5 header structures are python dictionaries, serialized for</span>
<span class="sd">        hdf5 storage as JSON strings, and tucked into the hdf5</span>
<span class="sd">        attribute so they travel with the datablock.</span>

<span class="sd">        The dblock header holds information collected/generated from</span>
<span class="sd">        various sources. Some is read from dig .crw/.log file headers,</span>
<span class="sd">        some is generated at runtime as the dig data is converted to</span>
<span class="sd">        mkh5 format. Some is generated/merged in at runtime when the</span>
<span class="sd">        YAML YAML header info file is processed</span>

<span class="sd">        * native .crw header from the info dict returned by</span>
<span class="sd">          mkio._read_header()</span>

<span class="sd">        * mkh5/hdf5 info added by mkh5_read_raw_log()</span>

<span class="sd">          - miscellanous</span>
<span class="sd">          - data stream specs, 1-1 with the dblock data columns</span>

<span class="sd">        * supplementary information specified in a YAML format text</span>
<span class="sd">          file and loaded along with the ``.crw`` and ``.log`` files</span>
<span class="sd">          when they are converted to the dblock, HDF5 format.</span>

<span class="sd">        The .crw/.dig header can be extended by loading it from a YAML</span>
<span class="sd">        file. See _load_yhdr() docstring for specs.</span>

<span class="sd">        &quot;&quot;&quot;</span>

<div class="viewcode-block" id="mkh5.HeaderIO.HeaderIOError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.HeaderIOError">[docs]</a>        <span class="k">class</span> <span class="nc">HeaderIOError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.HeaderIO.YAMLClobberError"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.YAMLClobberError">[docs]</a>        <span class="k">class</span> <span class="nc">YAMLClobberError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;raised when a YAML header file tries to overwrite an mkh5 header reserved word</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hio</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;These are mkh5 header reserved words: &quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hio</span><span class="o">.</span><span class="n">_mkh5_header_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> YAML header files are not allowed to change </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">yhdr_f</span><span class="p">,</span> <span class="n">keyword</span>
                <span class="p">)</span></div>

        <span class="c1"># template for minimal mkh5 datablock header</span>
        <span class="c1"># These are top-level keys. The header checkers enforce these</span>
        <span class="c1"># keys and data types and the streams keys and data types.</span>
        <span class="c1"># Everything else in the header is ad lib.</span>
        <span class="n">_mkh5_header_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1"># as returned by mkio._load_header() from the .crw/.raw</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># hardcoded in mkio as &quot;dig&quot;</span>
            <span class="s2">&quot;magic&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># magic number from dig header</span>
            <span class="s2">&quot;subdesc&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># header[&quot;subdes&quot;]</span>
            <span class="s2">&quot;expdesc&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># header[&quot;expdes&quot;]</span>
            <span class="s2">&quot;odelay&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># header[&quot;odelay&quot;], # ms from trigger to stim about 8 @60Hz</span>
            <span class="s2">&quot;samplerate&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>  <span class="c1"># hz,</span>
            <span class="s2">&quot;recordduration&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>  <span class="c1"># length of each record in seconds</span>
            <span class="s2">&quot;recordsize&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># e.g., 256  # ns * nr of samples in each data record</span>
            <span class="s2">&quot;nrawrecs&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># number of raw records</span>
            <span class="s2">&quot;nchans&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># : header[&quot;nchans&quot;], # number of channels</span>
            <span class="c1"># set during when mkh5._read_raw_log() reads .crw, .log</span>
            <span class="s2">&quot;eeg_file&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># .crw file name as passed to _read_raw_log</span>
            <span class="s2">&quot;eeg_file_md5&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="s2">&quot;log_file&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># .log file name as passed to _read_raw_log</span>
            <span class="s2">&quot;log_file_md5&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="c1"># (&#39;uuid_file&#39;, str),     # not implemented</span>
            <span class="s2">&quot;streams&quot;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>  <span class="c1">#  items are 1-1 (unordered) for dblock columns</span>
            <span class="s2">&quot;h5_dataset&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># set upon construction to the dblock h5py.Dataset.name</span>
        <span class="p">}</span>

        <span class="c1"># minimal stream item upon loading into .crw/.log info into a mkh5.dblock_N</span>
        <span class="n">_mkh5_header_stream_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># dig channel name, e.g., &#39;lle&#39;, &#39;MiPf&#39;</span>
            <span class="s2">&quot;jdx&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># column index in dblock_N dataset, 0, 1, ...</span>
            <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># source pfx[NNNN] where pfx = eeg|log|other, NNNN enumerates</span>
            <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>  <span class="c1"># string np.dtype, e.g., &#39;&lt;f2&#39;, &#39;&lt;i4&#39;</span>
            <span class="c1"># from mkh5._h5_update_eeg() where h5_path + dblock_id is the</span>
        <span class="p">}</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;wake up&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_json_key</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;json_header&quot;</span>
            <span class="p">)</span>  <span class="c1"># key used to access h5py.Dataset.attrs[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slicer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># PUBLIC CRUD</span>
        <span class="c1">#</span>
        <span class="c1">#  CRU *D*: Delete not implemented</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;expose header data like a read-only attribute&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span>

        <span class="c1"># Create/Update</span>
<div class="viewcode-block" id="mkh5.HeaderIO.new"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.new">[docs]</a>        <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdr_dict</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;merge a dictionary and dict from the YAML file into a well-formed</span>
<span class="sd">               mkh5 datablock header or die</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create</span><span class="p">(</span><span class="n">hdr_dict</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span></div>

        <span class="c1"># read</span>
<div class="viewcode-block" id="mkh5.HeaderIO.get"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.get">[docs]</a>        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dblock</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;load header info from dblock into self._header</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            dblock : h5py.Dataset </span>
<span class="sd">               The HDF5 dataset whose attribute &#39;json_header&#39; holds the header JSON string. </span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dblock</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;dblock must be an h5py.Dataset not &quot;</span> <span class="o">+</span> <span class="n">dblock</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_json_key</span> <span class="ow">in</span> <span class="n">dblock</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">json_str</span> <span class="o">=</span> <span class="n">dblock</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_json_key</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
                <span class="n">json_str</span>
            <span class="p">)</span>  <span class="c1"># decode json into the header dict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_streams</span><span class="p">(</span>
                <span class="n">dblock</span>
            <span class="p">)</span>  <span class="c1"># are header streams 1-1 with datablock columns?</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>  <span class="c1"># general header check</span></div>

        <span class="c1"># update</span>
<div class="viewcode-block" id="mkh5.HeaderIO.set"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.set">[docs]</a>        <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dblock</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;jsonify the current self._header as value of dblock.attrs[self._json_key]</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            dblock : h5py.Dataset</span>
<span class="sd">              writeable mkh5 datablock reference</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dblock</span><span class="p">,</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;dblock must be an h5py.Dataset not &quot;</span> <span class="o">+</span> <span class="n">dblock</span><span class="o">.</span><span class="vm">__class__</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s2">&quot;h5_dataset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dblock</span><span class="o">.</span><span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_streams</span><span class="p">(</span><span class="n">dblock</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>

            <span class="c1"># good to go ...jsonify stuff the string into the hdf5 attribute</span>
            <span class="n">json_header</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_header</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;jsonified header info exceeds 64KB ... too big for hdf5 attribute&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">dblock</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_json_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">json_header</span></div>

        <span class="c1"># C *R *UD:  header content retrieval</span>
<div class="viewcode-block" id="mkh5.HeaderIO.set_slicer"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.set_slicer">[docs]</a>        <span class="k">def</span> <span class="nf">set_slicer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;load YAML header slicer for selecting subsets of mkh5 header values</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            slicer_f : str</span>
<span class="sd">                 YAML file in mkh5 header slicer format</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            None</span>
<span class="sd">                side effect: sets self._slicer</span>


<span class="sd">            * The mkh5 header is a tree structure (dict) with branches</span>
<span class="sd">              that terminate in data.</span>

<span class="sd">            * The mkh5 header slicer is an mkh5 header subtree</span>
<span class="sd">              &quot;template&quot; that contains</span>

<span class="sd">              - terminating branches only</span>
<span class="sd">              - string labels as terminals, e.g., col_0, col_1</span>
<span class="sd">             </span>
<span class="sd">            Ex. , [&#39;key_0&#39;, &#39;key_1&#39;, ... &#39;key_i&#39;, col_0]</span>

<span class="sd">            * Walking through header slicer with dpath.util.get(path)</span>
<span class="sd">              fetches the data value at the end of the path and we</span>
<span class="sd">              label it with the slicer column name like so</span>
<span class="sd">             </span>
<span class="sd">                [ (col_0, val_0), ... (col_n, val_n)]</span>

<span class="sd">            This converts neatly to wide tabular format</span>

<span class="sd">            +---------+------+----------+</span>
<span class="sd">            |col_0    | ...  | col_j    |</span>
<span class="sd">            +=========+======+==========+</span>
<span class="sd">            | value_1 | ...  | value_n  |</span>
<span class="sd">            +---------+------+----------+</span>

<span class="sd">            Examples</span>

<span class="sd">            .. code-block:: yaml</span>

<span class="sd">               # here is some YAML header info</span>
<span class="sd">               ---</span>
<span class="sd">               runsheet:</span>
<span class="sd">                 age: 22</span>
<span class="sd">                 SAT_math: 720</span>
<span class="sd">                 SAT_verbal: 680</span>
<span class="sd">                 handedness: L/L</span>
<span class="sd">                 mood_VAS: 4.5</span>

<span class="sd">            The YAML header slicer follows matching paths into that header </span>
<span class="sd">            to pluck out the terminal data values (leafs) and (re-)label them</span>

<span class="sd">            .. code-block:: yaml</span>

<span class="sd">               # here is an extractor for the header</span>
<span class="sd">               ---</span>
<span class="sd">               runsheet:</span>
<span class="sd">                 mood_VAS: mood</span>
<span class="sd">                 handedness: fam_hand</span>
<span class="sd">                 age: age</span>

<span class="sd">            .. note:: </span>
<span class="sd">               ``key:value`` order does not matter</span>

<span class="sd">            This next slicer specifies the same **paths** into the</span>
<span class="sd">            header tree and extracts exactly the same **values**</span>

<span class="sd">            .. code-block:: yaml</span>

<span class="sd">               ---</span>
<span class="sd">               runsheet:</span>
<span class="sd">                 age: age</span>
<span class="sd">                 handedness: fam_hand</span>
<span class="sd">                 mood_VAS: mood</span>

<span class="sd">            The slicer paths are the same for both:</span>

<span class="sd">              runsheet/mood_VAS/mood</span>

<span class="sd">              runsheet/handedness/fam_hand  </span>

<span class="sd">              runsheet/age/age  </span>
<span class="sd">            </span>
<span class="sd">            Algorithm</span>

<span class="sd">            * HeaderIO.get_slices() extracts the header values at the end of the path, i.e.,</span>
<span class="sd">              22, L/L, 4.5 and pairs each datum with its path-matching slicer label like so</span>

<span class="sd">                [ (sub_age, 22), (fam_hand, &#39;L/L&#39;) ]</span>

<span class="sd">            * mkh5.get_event_table() converts these to wide-format and</span>
<span class="sd">              merges them with the rest of the single trial event code</span>
<span class="sd">              column information it gets from the code tag mapper.</span>

<span class="sd">               sub_age fam_hand</span>
<span class="sd">               22      &#39;L/L&#39;</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slicer_f</span> <span class="o">=</span> <span class="n">slicer_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_slicer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_yaml_slicer</span><span class="p">(</span><span class="n">slicer_f</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span></div>

        <span class="k">def</span> <span class="nf">_load_xlsx_slicer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;load code slicer from Excel .xlsx file and return pandas</span>
<span class="sd">            DataFrame. Default is first sheet, use slicer_f!sheet_name</span>
<span class="sd">            to select sheet_name</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># if a sheet is specified w/ slicer!sheet use it, otherwise</span>
            <span class="c1"># set to 0 for default first sheet</span>
            <span class="n">slicer_f_reob</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;(?P&lt;xl_f&gt;.+\.xls[xm])[\!]*(?P&lt;sheet_name&gt;.*)$&quot;</span><span class="p">,</span> <span class="n">slicer_f</span>
            <span class="p">)</span>
            <span class="n">xl_f</span> <span class="o">=</span> <span class="n">slicer_f_reob</span><span class="p">[</span><span class="s2">&quot;xl_f&quot;</span><span class="p">]</span>
            <span class="n">sheet_name</span> <span class="o">=</span> <span class="n">slicer_f_reob</span><span class="p">[</span><span class="s2">&quot;sheet_name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sheet_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sheet_name</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">slicer</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_excel</span><span class="p">(</span>
                <span class="n">xl_f</span><span class="p">,</span> <span class="n">sheet_name</span><span class="o">=</span><span class="n">sheet_name</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;Index&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">slicer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">slicer</span>

        <span class="k">def</span> <span class="nf">_load_txt_slicer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;load tab-separated UTF-8 text file and return pandas DataFrame&quot;&quot;&quot;</span>
            <span class="k">raise</span> <span class="bp">NotImplemented</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">slicer_f</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">mapper</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span>
                    <span class="n">slicer_f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s2">&quot;Index&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">mapper</span>

        <span class="k">def</span> <span class="nf">_load_yaml_slicer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slicer_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;load yaml mapper file and return pandas DataFrame&quot;&quot;&quot;</span>

            <span class="c1"># slurp the slicer</span>
            <span class="n">slicer_dict</span><span class="p">,</span> <span class="n">hdocs</span><span class="p">,</span> <span class="n">md5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_yaml_docs</span><span class="p">(</span><span class="n">slicer_f</span><span class="p">)</span>
            <span class="n">slicers</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">slicer_paths</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">dpath</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">paths_only</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dpath</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">paths</span><span class="p">(</span><span class="n">slicer_dict</span><span class="p">,</span> <span class="n">dirs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">leaves</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">slicer_paths</span><span class="p">:</span>
                <span class="n">slicers</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">path</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">slicers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">slicers</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">slicers</span>

<div class="viewcode-block" id="mkh5.HeaderIO.get_slices"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.HeaderIO.get_slices">[docs]</a>        <span class="k">def</span> <span class="nf">get_slices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;slice out data values from dblock header for use in event table columns</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            slicer : dict</span>
<span class="sd">               dictionary of col_name: slash_pattern where,</span>
<span class="sd">               * col_name (string) is the dict key that will appear as a table column heading</span>
<span class="sd">               * search_path (list of strings) as [ &#39;key1&#39;, &#39;key2&#39;, ... key_n] to probe header</span>

<span class="sd">            Returns</span>
<span class="sd">            -------</span>
<span class="sd">            slicer : list of 2-ples, possibly empty)</span>
<span class="sd">                each tuple is (col_name, datum) where</span>
<span class="sd">            datum : object</span>
<span class="sd">                leaf returned by dpath.util.get(self._header, search_path)</span>

<span class="sd">            Raises</span>
<span class="sd">            ------</span>
<span class="sd">            RuntimeError if HeaderIO instance doesn&#39;t have self._header or self._slicer dicts</span>
<span class="sd">            RuntimeError if dpath.util.get finds multiple values</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;load header from a datablock with HeaderIO.get(dblock) &quot;</span>
                    <span class="s2">&quot;before slicing&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slicer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_slicer</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;set self._slicer = HeaderIO._load_yaml_docs(yaml_f) &quot;</span>
                    <span class="s2">&quot;before slicing&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">hdr_paths</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dpath</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">paths</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">dirs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">leaves</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slicer</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">this_slice</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">datum</span> <span class="o">=</span> <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                    <span class="n">this_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">datum</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fail</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                        <span class="n">this_slice</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">))</span>  <span class="c1"># key not found</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">fail</span><span class="p">,</span> <span class="ne">ValueError</span>
                    <span class="p">):</span>  <span class="c1"># multiple values ... shouldn&#39;t happen</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;mutiple leaves match dpath glob ... but how?&quot;</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;some horrible error in HeaderIO.get_slices()&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">fail</span>
                <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_slice</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">slices</span>  <span class="c1"># possibly empty</span></div>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># PRIVATE-ish CRUD</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># this is the only way to form an mkh5 header dict ... seed_dict + YAML</span>
        <span class="k">def</span> <span class="nf">_create</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed_dict</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;merges seed_dict ON TOP of the YAML and set self._header&quot;&quot;&quot;</span>

            <span class="c1"># yhdr_f Path should be stringified by mkh5.create_mkdata</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">yhdr_f</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">HeaderIOError</span><span class="p">(</span>
                    <span class="n">f</span><span class="s2">&quot;please report mkpy bug: </span><span class="si">{yhdr_f}</span><span class="s2"> must be a str not {type(yhdr_f)}&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;seed_dict is not a dict&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">seed_dict</span>

            <span class="c1"># mkh5 headers know about the h5_path/block_id but</span>
            <span class="c1"># dicts pulled from .crw headers don&#39;t, so add a stub</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;h5_dataset&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seed_dict</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="c1"># load YAML info and merge it in</span>
            <span class="n">yhdr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_yhdr</span><span class="p">(</span><span class="n">yhdr_f</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">yhdr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_from_dict</span><span class="p">(</span><span class="n">yhdr</span><span class="p">,</span> <span class="n">keep_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_update_from_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">,</span> <span class="n">keep_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Update current header dictionary from other dictionary.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            keep_existing : bool, default is True</span>
<span class="sd">                ``True`` protects self._header[k] from being overwritten</span>
<span class="sd">                by new_dict[k]. ``False`` allows ``new_dict[k]`` to overwrite</span>
<span class="sd">                ``self._header[k]``</span>

<span class="sd">            Notes</span>
<span class="sd">            -----</span>
<span class="sd">            dpath.util.merge(A,B) merges B **ON TOP** of A, so</span>
<span class="sd">            B[key]:value sets (overwrites) A[key]:value.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">keep_existing</span><span class="p">:</span>
                <span class="c1"># merge existing on top of the new to preserve existing</span>
                <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">new_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">new_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># merge new on top of existing to clobber the new</span>
                <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">new_dict</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_update_from_slashpaths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slash_vals</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; header date via dpath (slash_path:value) syntax</span>

<span class="sd">            Parameters:</span>

<span class="sd">            slash_vals (slashpath, value) 2ple or iteratble of them</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">sv</span> <span class="ow">in</span> <span class="n">slash_vals</span><span class="p">:</span>
                <span class="c1"># gate keeper</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;to set header with slashpath use a (&#39;slash/path&#39;, value) 2-ple&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot; or a list of them&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c1"># FIX ME: protect reserved keys??</span>
                <span class="n">old_val</span> <span class="o">=</span> <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="c1"># print(&#39;new key:value &#39;, sv[0], sv[1])</span>
                    <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># print(&#39;setting existing key &#39;, sv[0], &#39;old: &#39;, old_val, &#39;new: &#39;, sv[1])</span>
                    <span class="n">nset</span> <span class="o">=</span> <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">nset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;failed to set &quot;</span> <span class="o">+</span> <span class="n">sv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; = &quot;</span> <span class="o">+</span> <span class="n">sv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_load_yaml_docs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yml_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;generic multi-doc YAML loader for header data and extractor files&quot;&quot;&quot;</span>

            <span class="c1"># FIX ME: add YAML linter</span>
            <span class="c1"># check for legal yaml</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">yml_f</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">yml_str</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">hdocs</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load_all</span><span class="p">(</span><span class="n">yml_str</span><span class="p">,</span> <span class="n">Loader</span><span class="o">=</span><span class="n">yaml</span><span class="o">.</span><span class="n">SafeLoader</span><span class="p">)</span>
                <span class="n">yml_f_md5</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">yml_str</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

            <span class="c1"># load up the docs w/ modicum of error checking</span>
            <span class="n">yml</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">doc_names</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hdoc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hdocs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">hdoc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;uh oh ... empty YAML document in &quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> perhaps a stray ---&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">yml_f</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">YamlHeaderFormatError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hdoc</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load_yaml_docs</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> document </span><span class="si">{1}</span><span class="s2"> does not have a name&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">yml_f</span><span class="p">,</span> <span class="n">i</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">YamlHeaderFormatError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hdoc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> document </span><span class="si">{1}</span><span class="s2">: length of name appears to be 0&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">yml_f</span><span class="p">,</span> <span class="n">i</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">YamlHeaderFormatError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">hdoc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">doc_names</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> duplicate document name </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">yml_f</span><span class="p">,</span> <span class="n">hdoc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">YamlHeaderFormatError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># the &quot;dig&quot; keys are not nested under the document name</span>
                    <span class="k">if</span> <span class="n">hdoc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;dig&quot;</span><span class="p">:</span>
                        <span class="n">dpath</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">yml</span><span class="p">,</span> <span class="n">hdoc</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">doc_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hdoc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
                        <span class="n">yml</span><span class="p">[</span><span class="n">hdoc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">hdoc</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">yml</span><span class="p">,</span> <span class="n">doc_names</span><span class="p">,</span> <span class="n">yml_f_md5</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_load_yhdr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;load a YAML format header extension</span>
<span class="sd">            </span>
<span class="sd">            Syntax: </span>
<span class="sd">  </span>
<span class="sd">            * Must conform to YAML spec (?2.0)</span>

<span class="sd">            * There MUST be at least one YAML document</span>

<span class="sd">            * EACH YAML docs must contain a ``name`` key and string</span>
<span class="sd">              value</span>

<span class="sd">            OPTIONAL</span>
<span class="sd">             </span>
<span class="sd">            * Additional YAML documents may be added to the file ad lib provided</span>
<span class="sd">              each document is named with a key-value pair like so</span>

<span class="sd">                ---</span>
<span class="sd">                name: doc_name</span>

<span class="sd">              where doc_name is a string and not used for any other</span>
<span class="sd">              document in the file.</span>

<span class="sd">            * Additional YAML data may be specified ad lib. to extend</span>
<span class="sd">              any document or data.</span>


<span class="sd">            * Apparatus doc is a fixed-format map with these keys and</span>
<span class="sd">              values</span>
<span class="sd">        </span>
<span class="sd">                 name: &quot;apparatus&quot;</span>
<span class="sd">                 space: </span>
<span class="sd">                 fiducial: </span>
<span class="sd">                 sensor: </span>
<span class="sd">                 stream: </span>


<span class="sd">             The ``fiducial``, ``sensor``, and ``stream`` data are</span>
<span class="sd">             each given as 2-level maps where the top level key gives</span>
<span class="sd">             the &quot;name&quot;, e.g., lle, MiPf, HEOG, nasion and the nested</span>
<span class="sd">             key:value pairs give the value of the key, e.g., gain:</span>
<span class="sd">             10000 for an amplifier channel or x: 18.9 for 3D</span>
<span class="sd">             coordinate x. This affords easy conversion to tabular</span>
<span class="sd">             format where top level keys index rows and, nested keys</span>
<span class="sd">             are column labels, and nested values are column data.</span>

<span class="sd">             * fiducial must contain top-level keys &quot;nasion&quot;, &quot;lpa&quot;,</span>
<span class="sd">               &quot;rpa&quot; and nested keys x, y, z</span>

<span class="sd">             * sensor must contain top-level keys naming electrodes,</span>
<span class="sd">               e.g. lle, MiPf and nested keys x, y, z</span>

<span class="sd">             * stream must contain top-level keys naming digital data</span>
<span class="sd">               channels, e.g., lle, MiPf, HEOG (note these are</span>
<span class="sd">               recordings/data streams *NOT* electrodes).  Nested keys</span>
<span class="sd">               must contain pos, neg indicating, respectively, the</span>
<span class="sd">               positive polarity sensor and its reference (a string</span>
<span class="sd">               name) which may be another electrode (A1, lhz) or not</span>
<span class="sd">               (avg).</span>

<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">yhdr</span><span class="p">,</span> <span class="n">doc_names</span><span class="p">,</span> <span class="n">yhdr_md5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_yaml_docs</span><span class="p">(</span><span class="n">yhdr_f</span><span class="p">)</span>

            <span class="c1"># make sure the YAML dict doesn&#39;t step on basic top-level header info</span>
            <span class="n">new_keys</span> <span class="o">=</span> <span class="n">yhdr</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">h_key</span><span class="p">,</span> <span class="n">h_type</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mkh5_header_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">h_key</span> <span class="ow">in</span> <span class="n">new_keys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">YAMLClobberError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h_key</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">)</span>

            <span class="c1"># enforce special case requirements here</span>
            <span class="k">if</span> <span class="s2">&quot;apparatus&quot;</span> <span class="ow">in</span> <span class="n">doc_names</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;space&quot;</span><span class="p">,</span> <span class="s2">&quot;fiducials&quot;</span><span class="p">,</span> <span class="s2">&quot;sensors&quot;</span><span class="p">,</span> <span class="s2">&quot;streams&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">yhdr</span><span class="p">[</span><span class="s2">&quot;apparatus&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> apparatus document </span><span class="si">{1}</span><span class="s2"> map not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">yhdr_f</span><span class="p">,</span> <span class="n">m</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">YamlHeaderFormatError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># self-identify</span>
            <span class="n">yhdr</span><span class="p">[</span><span class="s2">&quot;yhdr_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yhdr_f</span>
            <span class="n">yhdr</span><span class="p">[</span><span class="s2">&quot;yhdr_file_md5&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yhdr_md5</span>
            <span class="k">return</span> <span class="n">yhdr</span>

        <span class="k">def</span> <span class="nf">_check_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;enforce mandatory minimum mkh5 header data structure&quot;&quot;&quot;</span>

            <span class="c1"># check for mandatory keys and values of the right type</span>
            <span class="n">header_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">h_key</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mkh5_header_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">h_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header_keys</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">f</span><span class="s1">&#39;uh oh ... mandatory key &quot;</span><span class="si">{h_key}</span><span class="s1">&quot; is missing from  &#39;</span>
                        <span class="s2">&quot;mkh5 dblock header:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">h_key</span><span class="p">],</span> <span class="n">dtype</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;uh oh ... bad header value datatype: &quot;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> should be </span><span class="si">{1}</span><span class="s2"> not </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">h_key</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">h_key</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># check the stream items</span>
            <span class="n">mand_stream_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mkh5_header_stream_types</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="n">mand_stream_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mkh5_header_stream_types</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">sk</span><span class="p">,</span> <span class="n">sv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">sk</span> <span class="ow">in</span> <span class="n">mand_stream_keys</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                        <span class="n">sv</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mkh5_header_stream_types</span><span class="p">[</span><span class="n">sk</span><span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;uh oh ... stream </span><span class="si">{0}</span><span class="s1">[&quot;</span><span class="si">{1}</span><span class="s1">&quot;] bad value datatype: &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">sk</span><span class="p">,</span> <span class="n">sv</span>
                        <span class="p">)</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;should be </span><span class="si">{1}</span><span class="s2"> not </span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_mkh5_header_stream_types</span><span class="p">[</span><span class="n">sk</span><span class="p">],</span> <span class="n">sv</span><span class="o">.</span><span class="vm">__class__</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_check_streams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dblock</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;enforce agreement between self._header streams and the data block</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>

<span class="sd">            dblock (h5py.Dataset) readble mkh5 data block (reference)</span>

<span class="sd">            * checks the fields in _mkh5_header_stream_types</span>
<span class="sd">            _mkh5_header_stream_types = {</span>
<span class="sd">            &#39;name&#39;: str,   # dig channel name, e.g., &#39;lle&#39;, &#39;MiPf&#39;</span>
<span class="sd">            &#39;jdx&#39;: int,    # column index in dblock_N dataset, 0, 1, ...</span>
<span class="sd">            &#39;source&#39;: str, # source pfx[NNNN] where pfx = eeg|log|other, NNNN enumerates</span>
<span class="sd">            &#39;dt&#39;: str,     # string np.dtype, e.g., &#39;&lt;f2&#39;, &#39;&lt;i4&#39;</span>
<span class="sd">            # from mkh5._h5_update_eeg() where h5_path + dblock_id is the </span>

<span class="sd">            </span>
<span class="sd">            Raises:</span>
<span class="sd">            </span>
<span class="sd">            RuntimeError on mismatch</span>
<span class="sd">            columns: labels, column order=jdx, and data type</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_header</span><span class="p">()</span>  <span class="c1"># first things first</span>
            <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dblock</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="k">assert</span> <span class="n">jdx</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">][</span><span class="n">col</span><span class="p">][</span><span class="s2">&quot;jdx&quot;</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="p">(</span>
                        <span class="n">dblock</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">][</span><span class="n">col</span><span class="p">][</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;uh oh ... header[&#39;streams&#39;] is missing a data block column&quot;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dblock</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
                    <span class="n">this_jdx</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;jdx&quot;</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="n">dblock</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">this_jdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span>
                    <span class="k">assert</span> <span class="n">dblock</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">this_jdx</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;uh oh ... header[&#39;streams&#39;] has an extra stream&quot;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>

    <span class="c1"># log data types ... ticks are uint64, everything else can be int16</span>
    <span class="c1"># _log_dtype = np.dtype([</span>
    <span class="c1">#     (&quot;log_evticks&quot;, _evtick),</span>
    <span class="c1">#     (&quot;log_evcodes&quot;, _evcode),</span>
    <span class="c1">#     (&quot;log_ccodes&quot;, _log_ccode),</span>
    <span class="c1">#     (&quot;log_flags&quot;, _log_flag),</span>
    <span class="c1"># ])</span>

    <span class="c1"># structure to merge dig marktrack and log info</span>
    <span class="c1"># FIX ME FOR EPOCHS</span>
    <span class="n">_event_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;evticks&quot;</span><span class="p">,</span> <span class="n">_evtick</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">,</span> <span class="n">_evcode</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">,</span> <span class="n">_evcode</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">,</span> <span class="n">_log_ccode</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;log_flags&quot;</span><span class="p">,</span> <span class="n">_log_flag</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="n">_dblock_slicer_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;start_samps&quot;</span><span class="p">,</span> <span class="n">_epoch_t</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;anchor_samps&quot;</span><span class="p">,</span> <span class="n">_epoch_t</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;stop_samps&quot;</span><span class="p">,</span> <span class="n">_epoch_t</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># define a datatype for the bin-event table ... essentially a decorated log</span>
    <span class="n">_bin_event_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;evticks&quot;</span><span class="p">,</span> <span class="n">_evtick</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">,</span> <span class="s2">&quot;i2&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">,</span> <span class="s2">&quot;u2&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;log_flags&quot;</span><span class="p">,</span> <span class="s2">&quot;u2&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;bin_nums&quot;</span><span class="p">,</span> <span class="s2">&quot;u2&quot;</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;bin_descs&quot;</span><span class="p">,</span> <span class="s2">&quot;S64&quot;</span><span class="p">),</span>  <span class="c1"># icky ... hardcoded string lengths</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># FIX ME ... non-event type epoch?</span>
    <span class="n">_epoch_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;anchor_ticks&quot;</span><span class="p">,</span> <span class="n">_evtick</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">,</span> <span class="n">_evcode</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;epoch_starts&quot;</span><span class="p">,</span> <span class="n">_evtick</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;epoch_stops&quot;</span><span class="p">,</span> <span class="n">_evtick</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># for dumping instance info ...</span>
    <span class="c1"># pp = pprint.PrettyPrinter(indent=4)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5name</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;initialize and set mkh5 file name for this instance. If the file</span>
<span class="sd">           doesn&#39;t exist, create it. If it exists, test read/writeability</span>

<span class="sd">        Parameters:</span>

<span class="sd">            h5name (string) file path to the mkh5 format hdf5 file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h5name</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="n">h5name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">h5name</span><span class="p">)</span>

        <span class="c1"># each mkh5 instance is tied to one and only one hdf5 format file</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;h5name is &quot;</span> <span class="o">+</span> <span class="n">h5name</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span> <span class="o">=</span> <span class="n">h5name</span>

        <span class="c1"># if file doesn&#39;t exist open, an empty hdf5 file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_all</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># file exists, warn if not readable or read-writable</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
                <span class="n">source_ver</span> <span class="o">=</span> <span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># major version</span>

                <span class="k">if</span> <span class="s2">&quot;version&quot;</span> <span class="ow">in</span> <span class="n">h5</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">file_ver</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">file_ver</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">file_ver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">source_ver</span> <span class="o">!=</span> <span class="n">file_ver</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;version mismatch: source==</span><span class="si">{0}</span><span class="s2"> file </span><span class="si">{1}</span><span class="s2">==</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">source_ver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">file_ver</span>
                    <span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># try to open for read-write and let h5py deal with problems</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> is read only&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># h5 introspection</span>
    <span class="k">def</span> <span class="nf">_headers_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header1</span><span class="p">,</span> <span class="n">header2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns boolean if all header dict keys and values are ==&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s2">&quot;FIX ME WITH dpath.utils NOW&quot;</span><span class="p">)</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">header1</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">header2</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># if k1==k2 can iterate on either set of keys</span>
        <span class="k">if</span> <span class="n">k1</span> <span class="o">!=</span> <span class="n">k2</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">([</span><span class="n">header1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">header2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">k1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># Public artifact tagging</span>
    <span class="c1"># ------------------------------------------------------------</span>
<div class="viewcode-block" id="mkh5.garv_data_group"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.garv_data_group">[docs]</a>    <span class="k">def</span> <span class="nf">garv_data_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_data_group_path</span><span class="p">,</span> <span class="n">skip_ccodes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Run `pygarv` on all the dblocks under the `h5_data_group_path`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_data_group_path : str</span>
<span class="sd">           name of the h5 datagroup containing the dblocks to screen</span>

<span class="sd">        skip_ccodes : list of uint, None ([0])</span>
<span class="sd">           dblocks with log_ccodes in the list are not scanned. Default</span>
<span class="sd">           is [0] to skip calibration blocks. Setting to None disables</span>
<span class="sd">           the skipper and scans all dblocks in the data group</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dblock_paths</span> <span class="o">=</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_dblock_paths</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">h5_data_group_path</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">dbp</span> <span class="ow">in</span> <span class="n">dblock_paths</span><span class="p">:</span>
            <span class="n">hdr</span><span class="p">,</span> <span class="n">dblock</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dblock</span><span class="p">(</span><span class="n">dbp</span><span class="p">)</span>

            <span class="c1"># ccodes can only change on dig start or pause so</span>
            <span class="c1"># homogenous on unless there is some goofy log</span>
            <span class="c1"># poking going on ...</span>
            <span class="n">log_event_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dblock</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">dblock</span><span class="p">[</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">][</span><span class="n">log_event_idxs</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="o">==</span> <span class="n">dblock</span><span class="p">[</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">][</span><span class="n">log_event_idxs</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">log_ccode</span> <span class="o">=</span> <span class="n">dblock</span><span class="p">[</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">][</span><span class="n">log_event_idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">skip_ccodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">log_ccode</span> <span class="ow">in</span> <span class="n">skip_ccodes</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;pygarv skipping </span><span class="si">{0}</span><span class="s2"> with &quot;</span> <span class="s2">&quot;log_ccode </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">dbp</span><span class="p">,</span> <span class="n">log_ccode</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">continue</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pygarving </span><span class="si">{0}</span><span class="s2"> log_ccode </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dbp</span><span class="p">,</span> <span class="n">log_ccode</span><span class="p">))</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
                <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;pygarv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygarv</span><span class="o">.</span><span class="n">_garv_dblock</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">dblock</span><span class="p">)</span></div>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># Public event code tag mapping and epoching utilities</span>
    <span class="c1"># ------------------------------------------------------------</span>
<div class="viewcode-block" id="mkh5.get_event_table"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.get_event_table">[docs]</a>    <span class="k">def</span> <span class="nf">get_event_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code_map_f</span><span class="p">,</span> <span class="n">header_map_f</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads the code tag and header extractor and returns an event lookup table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        code_map_f : str</span>
<span class="sd">            Excel, YAML, or tab-separated text, see mkh5 docs for format details.</span>
<span class="sd">        </span>

<span class="sd">        This sweeps the code tag map across the data to generate a lookup</span>
<span class="sd">        table for specific event (sequence patterns) where the rows specify</span>

<span class="sd">           1. slashpath to the mkh5 dblock data set and sample index</span>
<span class="sd">              for pattern-matching events.</span>

<span class="sd">           2. all the additional information for that pattern given in</span>
<span class="sd">              the code tag map</span>

<span class="sd">        The event table generated from mkh5 data and the code_map</span>
<span class="sd">        specification is in lieu of .blf (for EEG epoching and</span>
<span class="sd">        time-locking), .rts (for event-to-event timing), and .hdr (for</span>
<span class="sd">        experimental design specification).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># instantiate the codemapper w/ its map and code finder</span>
        <span class="n">ctagger</span> <span class="o">=</span> <span class="n">CodeTagger</span><span class="p">(</span><span class="n">code_map_f</span><span class="p">)</span>

        <span class="c1"># set up to extract info from the header</span>
        <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">header_map_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hio</span><span class="o">.</span><span class="n">set_slicer</span><span class="p">(</span><span class="n">header_map_f</span><span class="p">)</span>

        <span class="c1"># fetch all data that have at least one mkh5 datablock (dblock_0)</span>
        <span class="n">match_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dgroup_paths</span> <span class="o">=</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_data_group_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dgp</span> <span class="ow">in</span> <span class="n">dgroup_paths</span><span class="p">:</span>
                <span class="n">dblock_paths</span> <span class="o">=</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_dblock_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">dgp</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dbp</span> <span class="ow">in</span> <span class="n">dblock_paths</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">dgp</span> <span class="ow">in</span> <span class="n">dbp</span>  <span class="c1"># group and data block must agree</span>
                    <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">])</span>  <span class="c1"># need this for srate at least</span>

                    <span class="c1"># slice the header if there is an extractor</span>
                    <span class="k">if</span> <span class="n">hio</span><span class="o">.</span><span class="n">_slicer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">hdr_data</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">get_slices</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">hdr_data</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;searching codes in: &quot;</span> <span class="o">+</span> <span class="n">dbp</span><span class="p">)</span>
                    <span class="n">event_idxs</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                    <span class="p">)</span>  <span class="c1"># samples w/ non-zero events</span>
                    <span class="n">dblock_ticks</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;dblock_ticks&quot;</span><span class="p">][</span><span class="n">event_idxs</span><span class="p">]</span>
                    <span class="n">crw_ticks</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;crw_ticks&quot;</span><span class="p">][</span><span class="n">event_idxs</span><span class="p">]</span>
                    <span class="n">raw_evcodes</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">][</span><span class="n">event_idxs</span><span class="p">]</span>
                    <span class="n">log_evcodes</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">][</span><span class="n">event_idxs</span><span class="p">]</span>
                    <span class="n">log_ccodes</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">][</span><span class="n">event_idxs</span><span class="p">]</span>
                    <span class="n">log_flags</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">][</span><span class="s2">&quot;log_flags&quot;</span><span class="p">][</span><span class="n">event_idxs</span><span class="p">]</span>
                    <span class="c1"># iterate on keys which are the code patterns</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cm</span> <span class="ow">in</span> <span class="n">ctagger</span><span class="o">.</span><span class="n">code_map</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                        <span class="c1"># matches is a list of lists of dict, one dict for each group</span>
                        <span class="n">code_pattern_matches</span> <span class="o">=</span> <span class="n">ctagger</span><span class="o">.</span><span class="n">_find_evcodes</span><span class="p">(</span>
                            <span class="n">cm</span><span class="p">[</span><span class="s2">&quot;regexp&quot;</span><span class="p">],</span> <span class="n">dblock_ticks</span><span class="p">,</span> <span class="n">log_evcodes</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">code_pattern_matches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">code_pattern_matches</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                                    <span class="n">match_tick</span><span class="p">,</span> <span class="n">anchor_tick</span><span class="p">,</span> <span class="n">is_anchor</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="kc">None</span><span class="p">,</span>
                                        <span class="kc">None</span><span class="p">,</span>
                                        <span class="kc">None</span><span class="p">,</span>
                                    <span class="p">)</span>
                                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mm</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;match_tick&quot;</span><span class="p">:</span>
                                            <span class="n">match_tick</span> <span class="o">=</span> <span class="n">v</span>
                                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;anchor_tick&quot;</span><span class="p">:</span>
                                            <span class="n">anchor_tick</span> <span class="o">=</span> <span class="n">v</span>
                                        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;is_anchor&quot;</span><span class="p">:</span>
                                            <span class="n">is_anchor</span> <span class="o">=</span> <span class="n">v</span>
                                    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                                        <span class="p">[</span>
                                            <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                                            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span>
                                                <span class="n">match_tick</span><span class="p">,</span>
                                                <span class="n">anchor_tick</span><span class="p">,</span>
                                                <span class="n">is_anchor</span><span class="p">,</span>
                                            <span class="p">]</span>
                                        <span class="p">]</span>
                                    <span class="p">)</span>
                                    <span class="k">if</span> <span class="n">is_anchor</span><span class="p">:</span>
                                        <span class="k">assert</span> <span class="n">anchor_tick</span> <span class="o">==</span> <span class="n">match_tick</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="k">assert</span> <span class="n">anchor_tick</span> <span class="o">!=</span> <span class="n">match_tick</span>
                                    <span class="n">tick_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                                        <span class="n">dblock_ticks</span> <span class="o">==</span> <span class="n">match_tick</span>
                                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="k">assert</span> <span class="p">(</span>
                                        <span class="nb">len</span><span class="p">(</span><span class="n">tick_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                                    <span class="p">)</span>  <span class="c1"># better be a unique tick</span>
                                    <span class="n">sample_data</span> <span class="o">=</span> <span class="p">[</span>
                                        <span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span>
                                        <span class="p">(</span><span class="s2">&quot;data_group&quot;</span><span class="p">,</span> <span class="n">dgp</span><span class="p">),</span>
                                        <span class="p">(</span><span class="s2">&quot;dblock_path&quot;</span><span class="p">,</span> <span class="n">dbp</span><span class="p">),</span>
                                        <span class="p">(</span><span class="s2">&quot;dblock_tick_idx&quot;</span><span class="p">,</span> <span class="n">tick_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                        <span class="p">(</span>
                                            <span class="s2">&quot;dblock_ticks&quot;</span><span class="p">,</span>
                                            <span class="n">dblock_ticks</span><span class="p">[</span><span class="n">tick_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="p">),</span>
                                        <span class="p">(</span><span class="s2">&quot;crw_ticks&quot;</span><span class="p">,</span> <span class="n">crw_ticks</span><span class="p">[</span><span class="n">tick_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                                        <span class="p">(</span>
                                            <span class="s2">&quot;raw_evcodes&quot;</span><span class="p">,</span>
                                            <span class="n">raw_evcodes</span><span class="p">[</span><span class="n">tick_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="p">),</span>
                                        <span class="p">(</span>
                                            <span class="s2">&quot;log_evcodes&quot;</span><span class="p">,</span>
                                            <span class="n">log_evcodes</span><span class="p">[</span><span class="n">tick_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="p">),</span>
                                        <span class="p">(</span>
                                            <span class="s2">&quot;log_ccodes&quot;</span><span class="p">,</span>
                                            <span class="n">log_ccodes</span><span class="p">[</span><span class="n">tick_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="p">),</span>
                                        <span class="p">(</span><span class="s2">&quot;log_flags&quot;</span><span class="p">,</span> <span class="n">log_flags</span><span class="p">[</span><span class="n">tick_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span>
                                        <span class="p">(</span>
                                            <span class="s2">&quot;epoch_match_tick_delta&quot;</span><span class="p">,</span>
                                            <span class="mi">0</span><span class="p">,</span>
                                        <span class="p">),</span>  <span class="c1"># an event is a one sample epoch</span>
                                        <span class="p">(</span><span class="s2">&quot;epoch_ticks&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                        <span class="p">(</span>
                                            <span class="s2">&quot;dblock_srate&quot;</span><span class="p">,</span>
                                            <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;samplerate&quot;</span><span class="p">],</span>
                                        <span class="p">),</span>  <span class="c1"># for conversion to times</span>
                                    <span class="p">]</span>

                                    <span class="c1"># extend sample data w/ the header information</span>
                                    <span class="c1"># which may be None</span>
                                    <span class="n">sample_data</span> <span class="o">=</span> <span class="n">sample_data</span> <span class="o">+</span> <span class="n">hdr_data</span>

                                    <span class="c1"># extend sample_data w/ the match info and code map row</span>
                                    <span class="n">sample_data</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">sample_data</span>
                                        <span class="o">+</span> <span class="n">mm</span>
                                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">cm</span><span class="p">))</span>
                                    <span class="p">)</span>
                                    <span class="n">match_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                        <span class="p">(</span><span class="n">sample_data</span><span class="p">)</span>
                                    <span class="p">)</span>  <span class="c1"># list of tuples</span>
                                    <span class="c1"># pprint.pprint(match_list)</span>

        <span class="c1"># handle no matches ...</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">event_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="nb">dict</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">match_list</span><span class="p">])</span>
            <span class="n">event_table</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># do not use ... overmaps duplicate Indexs</span>
            <span class="c1"># event_table = pd.merge(event_table, ctagger.code_map,</span>
            <span class="c1">#                       left_index=True, right_index=True)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_h5_check_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">event_table</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">event_table</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;uh oh ... no events found for </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code_map_f</span><span class="p">)</span>
            <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_h5_check_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_f</span><span class="p">,</span> <span class="n">e_table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;check the match event in event or epoch table agrees with the</span>
<span class="sd">           dblock data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_f : str</span>
<span class="sd">            path to mkh5 format hdf5 file</span>
<span class="sd">        e_table: (pandas.DataFrame, np.ndarray)</span>
<span class="sd">            as returned by mkh5.get_event_table() </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None for success</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        RuntimeError on event_table[e] vs. dblock[e] mismatch or missing columns</span>


<span class="sd">        The minimum mandatory column names for an event table are</span>

<span class="sd">        * data_group: full slashpath to the h5py.Group covering a</span>
<span class="sd">          sequence of dblocks, e.g.,</span>

<span class="sd">              S001  </span>
<span class="sd">              Expt1/Session1/S047</span>

<span class="sd">        * dblock_path: full slashpath from the hdf5 root to one of the</span>
<span class="sd">          daughter dblock_N h5py.Datasets (without leading /), e.g.,</span>

<span class="sd">          S001/dblock_0</span>
<span class="sd">          Expt1/Session1/S047/dblock_12</span>

<span class="sd">        * dblock_ticks: the A/D sample counter which is also the row</span>
<span class="sd">          index of the dblock where the *matched* event appearing in</span>
<span class="sd">          the event table occurred. </span>

<span class="sd">        * match_code: the event code of the regexp pattern-matched</span>
<span class="sd">          group for this event table row. There is one match code for</span>
<span class="sd">          each capture group in the regular expression pattern, so </span>
<span class="sd">          the match code need not be the anchor code</span>
<span class="sd">        </span>
<span class="sd">        * All anchors are matches. Some matches may not be anchors</span>

<span class="sd">        * log_evcodes: the sequence of integer event codes occuring at</span>
<span class="sd">          each dblock tick in the original crw/log file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e_table</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">e_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">e_table</span><span class="p">)</span>

        <span class="n">min_cols</span> <span class="o">=</span> <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;data_group&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dblock_path&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dblock_ticks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_evcodes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;match_code&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">min_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">e_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;mkh5 event table column &quot;</span><span class="si">{0}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  is missing, all these are mandatory:&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">min_cols</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_f</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">e_table</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="c1"># These should only fail if the datablocks or event table have</span>
                <span class="c1"># been monkeyed with. Anyone who can do that can chase down</span>
                <span class="c1"># the assertion exception.</span>

                <span class="n">data</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_path&quot;</span><span class="p">]][</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_ticks&quot;</span><span class="p">]]</span>
                <span class="k">assert</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;data_group&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_path&quot;</span><span class="p">]</span>

                <span class="c1"># the log event code must be an anchor or a match</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;match_code&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;anchor_code&quot;</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;match_code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;anchor_code&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">]</span>
                <span class="n">check_cols</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">index</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">check_cols</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">e</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_epochs_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs_table</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;check a set epochs table for event codes, epoch length, and offset</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs_table : pd.DataFrame</span>
<span class="sd">           event table format with extra columns:</span>
<span class="sd">             epoch_ticks = fixed epoch duration in units of samples</span>
<span class="sd">             epoch_match_tick_delta = number of samples from epoch start to matched event code</span>

<span class="sd">        Returns</span>
<span class="sd">        ------- </span>
<span class="sd">           None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">           ValueError</span>
<span class="sd">             if epoch event codes and data blocks column values do not match the datablocks or </span>
<span class="sd">             epoch length and start offset values are not uniform across the epochs.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">epoch_required_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;epoch_ticks&quot;</span><span class="p">,</span> <span class="s2">&quot;epoch_match_tick_delta&quot;</span><span class="p">]</span>

        <span class="c1"># epochs tables are an extension of event tables, check the events first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5_check_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">epochs_table</span><span class="p">)</span>

        <span class="c1"># then epoch length and matched code offset (in samples)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">epoch_required_columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">epochs_table</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;epochs table missing required column </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">epochs_table</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;epochs table column </span><span class="si">{0}</span><span class="s2"> values must be the same: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">c</span><span class="p">,</span> <span class="n">vals</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_h5_check_epochs_table_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_f</span><span class="p">,</span> <span class="n">epochs_table_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;look up and check a previously set epochs table</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_f : str</span>
<span class="sd">           name of an mkh5 format HDF5 file, e.g., self.h5_fname or other</span>
<span class="sd">        epochs_table_name : str</span>
<span class="sd">           name of an epochs table, must exist in h5_f</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">           if something is wrong with the lookup or table itself</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">eptbl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_epochs_table</span><span class="p">(</span><span class="n">epochs_table_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_epochs_table</span><span class="p">(</span><span class="n">eptbl</span><span class="p">)</span>

<div class="viewcode-block" id="mkh5.set_epochs"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.set_epochs">[docs]</a>    <span class="k">def</span> <span class="nf">set_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs_table_name</span><span class="p">,</span> <span class="n">event_table</span><span class="p">,</span> <span class="n">tmin_ms</span><span class="p">,</span> <span class="n">tmax_ms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;construct and store a named EEG epochs lookup-table in self[&#39;epcochs&#39;]</span>

<span class="sd">        For storing in hdf5 the columns must be one of these:</span>
<span class="sd">          string-like (unicode, bytes)</span>
<span class="sd">          int-like (int, np.int, np.uint32, np.uint64)</span>
<span class="sd">          float-like (float, np.float32, np.float64)</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs_table_name : string</span>
<span class="sd">            name of the epochs table to store</span>

<span class="sd">        event_table : pandas.DataFrame</span>
<span class="sd">            as returned by mkh5.get_event_table()</span>

<span class="sd">        tmin_ms : float</span>
<span class="sd">            epoch start in millseconds relative to the event, e.g, -500</span>

<span class="sd">        tmax_ms : float</span>
<span class="sd">            epoch end in millseconds relative to the event, e..g,</span>
<span class="sd">            1500, strictly greater than tmin_ms</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            updates h5_f/epochs/ with the named epoch table h5py.Dataset</span>


<span class="sd">        The epochs table is a lightweight lookup table specific to</span>
<span class="sd">        this mkh5 instance&#39;s hdf5 file,</span>

<span class="sd">          h5[&#39;epochs&#39;][epochs_table_name] = epochs_table</span>

<span class="sd">        Event tables by default are &quot;epochs&quot; 1 sample long with 0</span>
<span class="sd">        prestimulus.</span>

<span class="sd">        This simply updates the prestimulus interval and length</span>
<span class="sd">        accordingly, adds the peri-event time interval information for</span>
<span class="sd">        slicing mkh5 datablocks and massages the event table</span>
<span class="sd">        (pandas.DataFrame) into a numpy ndarray for hdf5 storage.</span>

<span class="sd">        For reproducibility, by design epochs tables can be added to</span>
<span class="sd">        an mkh5 file but not overwritten or deleted. If you need to</span>
<span class="sd">        the revise the epochs, rebuild the mkh5 file from crws/logs</span>
<span class="sd">        with the ones you want.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;epochs&quot;</span> <span class="ow">in</span> <span class="n">h5</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">epochs_table_name</span> <span class="ow">in</span> <span class="n">h5</span><span class="p">[</span><span class="s2">&quot;epochs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">f</span><span class="s2">&quot;epochs name </span><span class="si">{epochs_table_name}</span><span class="s2"> is in use, &quot;</span>
                    <span class="n">f</span><span class="s2">&quot;pick another name or use reset_all() to &quot;</span>
                    <span class="n">f</span><span class="s2">&quot;completely wipe the mkh5 file: </span><span class="si">{self.h5_fname}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># event_table = self.get_event_table(code_map_f)</span>
        <span class="k">if</span> <span class="n">event_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;uh oh, event_table is empty&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5_check_events</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">event_table</span><span class="p">)</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># 1. sanitize the pandas.Dataframe columns</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sanitizing event table data types for mkh5 epochs table ...&quot;</span><span class="p">)</span>

        <span class="c1"># enforce Index data type is str or int</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">event_table</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">):</span>
                <span class="n">maxbytes</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">event_table</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)]</span>
                <span class="p">)</span>
                <span class="n">index_dt_type</span> <span class="o">=</span> <span class="s2">&quot;S&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">maxbytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">event_table</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
                <span class="n">index_dt_type</span> <span class="o">=</span> <span class="s2">&quot;int&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;uh oh, cannot convert event table index column to bytes or integer&quot;</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">err</span>

        <span class="c1"># move Index into columns for santizing</span>
        <span class="n">event_table</span> <span class="o">=</span> <span class="n">event_table</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">)</span>

        <span class="c1"># remap pandas &#39;O&#39; dtype columns to hdf5 friendly np.arrays if possible</span>
        <span class="n">tidy_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">event_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># do by column so failures are diagnostic. Pass in a copy</span>
            <span class="c1"># so nan handling can mod the series in place without</span>
            <span class="c1"># pd warning &quot;setting value on copy&quot;</span>
            <span class="n">tidy_table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pd_series_to_hdf5</span><span class="p">(</span><span class="n">event_table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">event_table</span> <span class="o">=</span> <span class="n">tidy_table</span>

        <span class="c1"># 2. define a numpy compound data type to hold the event_table</span>
        <span class="c1"># info and region refs</span>

        <span class="c1"># start with Epoch_idx</span>
        <span class="n">epoch_dt_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Epoch_idx&quot;</span><span class="p">]</span>
        <span class="n">epoch_dt_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uint64&quot;</span><span class="p">]</span>

        <span class="c1"># continue new dtype for event info columns, mapped to hdf5 compatible np.dtype</span>
        <span class="n">event_table_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">event_table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">event_table</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event_table</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">epoch_dt_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">epoch_dt_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event_table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>

        <span class="c1"># construct the new dtype and initialize the epoch np.array</span>
        <span class="n">epoch_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">epoch_dt_names</span><span class="p">,</span> <span class="n">epoch_dt_types</span><span class="p">)))</span>
        <span class="n">epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">event_table</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">epoch_dt</span><span class="p">)</span>

        <span class="c1"># set the Epoch_idx counting index and copy the tidied event table</span>
        <span class="n">epochs</span><span class="p">[</span><span class="s2">&quot;Epoch_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">event_table</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">event_table</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">epochs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_table</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="c1"># 3. time lock each epoch to the match tick, and set the</span>
        <span class="c1">#    interval from the function arguments</span>
        <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>

        <span class="c1"># init with nan and set to ms if epoch is in bounds</span>
        <span class="n">is_in_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="c1"># for i,e in event_table.iterrows():</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
                <span class="n">srate</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_srate&quot;</span><span class="p">]</span>

                <span class="c1"># check event table sampling rate agrees w/ dblock</span>
                <span class="n">dbp</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_path&quot;</span><span class="p">]</span>
                <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">srate</span> <span class="o">!=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;samplerate&quot;</span><span class="p">]:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">[&#39;samplerate&#39;]: </span><span class="si">{1}</span><span class="s2"> does not match &quot;</span>
                        <span class="s2">&quot;event table[</span><span class="si">{2}</span><span class="s2">][&#39;dblock_samplerate&#39;: &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{3}</span><span class="s2">&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dbp</span><span class="p">,</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;samplerate&quot;</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">srate</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">epoch_match_tick_delta</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_ms2samp</span><span class="p">(</span><span class="n">tmin_ms</span><span class="p">,</span> <span class="n">srate</span><span class="p">)</span>
                <span class="n">start_samp</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;match_tick&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">epoch_match_tick_delta</span>
                <span class="n">duration_samp</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_ms2samp</span><span class="p">(</span>
                    <span class="n">tmax_ms</span> <span class="o">-</span> <span class="n">tmin_ms</span><span class="p">,</span> <span class="n">srate</span>
                <span class="p">)</span>  <span class="c1"># must be non-negative</span>
                <span class="k">if</span> <span class="n">duration_samp</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;epoch interval </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> is less than one sample at &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{3}</span><span class="s2"> ... increase the interval&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tmin_ms</span><span class="p">,</span> <span class="n">tmax_ms</span><span class="p">,</span> <span class="n">srate</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="c1"># move on after bounds check</span>
                <span class="k">if</span> <span class="n">start_samp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;data error: pre-stimulus interval is out of bounds left ... &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;skipping epoch </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">start_samp</span> <span class="o">+</span> <span class="n">duration_samp</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">dbp</span><span class="p">]):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;data error: post-stimulus interval is out of bounds right ... &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;skipping epoch </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if in bounds, overwrite np.nan with the epoch start and duration</span>
                    <span class="n">is_in_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">e</span><span class="p">[</span><span class="s2">&quot;epoch_match_tick_delta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">epoch_match_tick_delta</span>
                    <span class="n">e</span><span class="p">[</span><span class="s2">&quot;epoch_ticks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration_samp</span>

        <span class="c1"># drop out of bounds epochs and check epochs are consistent</span>
        <span class="n">epochs</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="n">is_in_bounds</span><span class="p">]</span>

        <span class="c1"># check the epochs for consistency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_epochs_table</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>

        <span class="c1"># 4. add or overwrite the epochs in the mkh5 file under /epochs/epochs_table_name</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="n">epochs_path</span> <span class="o">=</span> <span class="s2">&quot;epochs/&quot;</span> <span class="o">+</span> <span class="n">epochs_table_name</span>
            <span class="n">ep</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">epochs_path</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tmin_ms&quot;</span><span class="p">:</span> <span class="n">tmin_ms</span><span class="p">,</span> <span class="s2">&quot;tmax_ms&quot;</span><span class="p">:</span> <span class="n">tmax_ms</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ep</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># ok</span></div>

<div class="viewcode-block" id="mkh5.export_event_table"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.export_event_table">[docs]</a>    <span class="k">def</span> <span class="nf">export_event_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_table</span><span class="p">,</span> <span class="n">event_table_f</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;feather&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetch the specified event table and save it in the specified format&quot;&quot;&quot;</span>
        <span class="n">known_formats</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;feather&quot;</span><span class="p">,</span> <span class="s2">&quot;txt&quot;</span><span class="p">]</span>  <span class="c1"># txt is tab-separated</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">known_formats</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;event_table export format must be &#39;feather&#39; or &#39;txt&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># event_table = self.get_event_table(code_map_f)</span>
        <span class="k">if</span> <span class="n">event_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;uh oh ... event_table is None for </span><span class="si">{0}</span><span class="s2"> ...&quot;</span> <span class="s2">&quot;nothing to export&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code_map_f</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;feather&quot;</span><span class="p">:</span>
            <span class="n">event_table</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">event_table</span><span class="o">.</span><span class="n">to_feather</span><span class="p">(</span><span class="n">event_table_f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;txt&quot;</span><span class="p">:</span>
            <span class="n">event_table</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">event_table_f</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">()</span></div>

<div class="viewcode-block" id="mkh5.get_epochs_table_names"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.get_epochs_table_names">[docs]</a>    <span class="k">def</span> <span class="nf">get_epochs_table_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a list, possibly empty of previously named epochs tables</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epochs_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
                <span class="n">epochs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">h5</span><span class="p">[</span><span class="s2">&quot;epochs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">epochs_names</span></div>

    <span class="k">def</span> <span class="nf">_pd_series_to_hdf5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">series</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;normalize pandas.Series +/- missing or nans to array for hdf5 serialization</span>

<span class="sd">        Parameter</span>
<span class="sd">        ---------</span>
<span class="sd">        series : pandas.Series</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        arry_hdf5 : np.array, shape (1,), dtype=column scalar dtype</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError if series is not pandas.Series</span>
<span class="sd">        ValueError if series is empty</span>
<span class="sd">        EpochsTableDataError if series data doesn&#39;t convert to hdf5</span>


<span class="sd">        Supported data types</span>
<span class="sd">        </span>
<span class="sd">        * a single, homogenous scalar data type drawn from these</span>
<span class="sd">    </span>
<span class="sd">           float-like: float, np.float32, np.float64, etc.</span>
<span class="sd">           int-like: int, np.int32, np.int64, etc. </span>
<span class="sd">           uint-like: np.uint32, np.uint64, etc.</span>
<span class="sd">           boolean-like: bool, np.bool</span>
<span class="sd">           string-like: str, bytes, unicode</span>

<span class="sd">        * missing data/NaNs are supported **except for boolean-like**</span>

<span class="sd">            NaN, None conversions as follows:</span>
<span class="sd">        </span>
<span class="sd">            Series type  |  from           | to hdf5</span>
<span class="sd">            ------------ | --------------  | ------------</span>
<span class="sd">            float-like   |  np.NaN, None   | np.nan</span>
<span class="sd">            int-like     |  pd.NaN, None   | np.nan, int coerced to float_</span>
<span class="sd">            uint-like    |  pd.NaN, None   | np.nan, int coerced to float_</span>
<span class="sd">            string-like  |  pd.NaN, None   | b&#39;NaN&#39;</span>
<span class="sd">            boolean-like |  pd.NaN, None   | not allowed</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Known dtypes according to pandas 0.21.0 return by infer_dtype</span>
<span class="sd">        </span>
<span class="sd">            empty (returned when all are None, undocumented in pandas)</span>
<span class="sd">         </span>
<span class="sd">            string, unicode, bytes, floating, integer,</span>
<span class="sd">            mixed-integer, mixed-integer-float, decimal,</span>
<span class="sd">            complex, categorical, boolean, datetime64,</span>
<span class="sd">            datetime, date, timedelta64, timedelta, time,</span>
<span class="sd">            period, mixed</span>

<span class="sd">        Approach: for mkh5 supported dtypes the pd.Series dtype &#39;O&#39; has 2 cases:</span>

<span class="sd">            - not hasnans</span>
<span class="sd">               - values are str_like -&gt; to bytes -&gt; np.array</span>
<span class="sd">               - values are mixed types -&gt; illegal, die</span>
<span class="sd">             </span>
<span class="sd">            - hasnans: two cases</span>
<span class="sd">               - the non-missing values are mixed types: illegal, die</span>
<span class="sd">               - the non-missing values are homogenous: handle by NaNs by type as above</span>
<span class="sd">                  - float_like -&gt; missing/None are already np.nan -&gt; np.array float</span>
<span class="sd">                  - int_like -&gt; replace nans w/ max int of dtype  -&gt; np.array float</span>
<span class="sd">                  - uint_like -&gt; replace nans w/ max uint of dtype -&gt; np.array float</span>
<span class="sd">                  - str_like -&gt; replace nans w/ &#39;NaN&#39; -&gt; to bytes -&gt; np.array bytes</span>
<span class="sd">                  - bool_like -&gt; NaN/missing illegal, die</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;wrong type </span><span class="si">{0}</span><span class="s2">: must be pandas.Series&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">series</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">series</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;empty series&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">pd_num_like</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;floating&quot;</span><span class="p">,</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;decimal&quot;</span><span class="p">,</span> <span class="s2">&quot;complex&quot;</span><span class="p">]</span>

        <span class="n">pd_bytes_like</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;unicode&quot;</span><span class="p">,</span>
            <span class="s2">&quot;bytes&quot;</span><span class="p">,</span>
            <span class="c1"># &#39;categorical&#39;, # ??</span>
        <span class="p">]</span>

        <span class="n">pd_bool_like</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;boolean&quot;</span><span class="p">]</span>

        <span class="n">pd_type</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span>
            <span class="n">series</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>  <span class="c1"># mixed if missing values present</span>
        <span class="c1"># pd_data_type = pd.api.types.infer_dtype(series.dropna()) # mixed if mixed data</span>
        <span class="n">pd_data_type</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">(</span>
            <span class="n">series</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>  <span class="c1"># mixed if mixed data</span>

        <span class="n">series_types</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">series</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
        <span class="n">data_types</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">series</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>

        <span class="c1"># homogonenous data w/ no missing values</span>

        <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>  <span class="c1">#</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">arry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;column &quot;</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">fail</span>
            <span class="k">assert</span> <span class="n">arry</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;O&quot;</span>
            <span class="k">return</span> <span class="n">arry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># white-list the allowed conversions, all else fails</span>

            <span class="c1"># any combination of str-like values +/- missing data -&gt; bytes +/- &#39;NaN</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_string_dtype</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">data_types</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">series</span><span class="o">.</span><span class="n">hasnans</span><span class="p">:</span>
                    <span class="n">series</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s2">&quot;.NAN&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># try each value to diagnosis if problem</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">series</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">value: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="s2">&quot;column: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">v</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span>
                        <span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">fail</span>

                <span class="c1"># now try whole series</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">arry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">series</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;column &quot;</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">fail</span>
                <span class="k">assert</span> <span class="n">arry</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;O&quot;</span>
                <span class="k">return</span> <span class="n">arry</span>

            <span class="c1"># handle num-like +/- missing data</span>
            <span class="k">elif</span> <span class="n">pd_data_type</span> <span class="ow">in</span> <span class="n">pd_num_like</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">arry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;column &quot;</span><span class="p">,</span> <span class="n">series</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">fail</span>
                <span class="k">assert</span> <span class="n">arry</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;O&quot;</span>
                <span class="k">return</span> <span class="n">arry</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># fail this blocks mixed numerics, boolean+NaN</span>
                <span class="k">raise</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">EpochsTableDataError</span><span class="p">(</span><span class="n">pd_data_type</span><span class="p">,</span> <span class="n">series</span><span class="p">)</span>

<div class="viewcode-block" id="mkh5.get_epochs_table"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.get_epochs_table">[docs]</a>    <span class="k">def</span> <span class="nf">get_epochs_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pandas&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;look up a previously set epochs table by name</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs_name : str</span>
<span class="sd">           name of a previously defined epochs table as set with an</span>
<span class="sd">           mkh5.set_epochs(event_table)</span>
<span class="sd">        format : str  {&#39;pandas&#39;, &#39;numpy&#39;}</span>
<span class="sd">           pandas.Dataframe or numpy.ndarray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">          epochs_table : pandas.Dataframe or numpy.ndarray</span>

<span class="sd">        Bytestrings from the hdf5 are converted to unicode epochs_table</span>
<span class="sd">        table returned</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="s2">&quot;numpy&quot;</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;format must be &#39;pandas&#39; or &#39;numpy&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">epochs_table</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="n">epochs_path</span> <span class="o">=</span> <span class="s2">&quot;epochs/&quot;</span> <span class="o">+</span> <span class="n">epochs_name</span>
            <span class="c1"># epochs_table = h5[epochs_path].value</span>
            <span class="n">epochs_table</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">epochs_path</span><span class="p">][</span><span class="o">...</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">epochs_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;epochs table not found: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">epochs_name</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># clean up hdf5 bytestrings</span>

        <span class="c1"># FIX ME for NANs?</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">epochs_table</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">epochs_table</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                <span class="n">dts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">epochs_table</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">epochs_table</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>

        <span class="n">eptbl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">epochs_table</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dts</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">epochs_table</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;decode&quot;</span><span class="p">):</span>
                    <span class="n">eptbl</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">eptbl</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># run consistency check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_epochs_table</span><span class="p">(</span><span class="n">eptbl</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;pandas&quot;</span><span class="p">:</span>
            <span class="n">eptbl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">eptbl</span><span class="p">)</span>
            <span class="n">eptbl</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">eptbl</span></div>

    <span class="k">def</span> <span class="nf">_h5_get_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs_name</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;merge datablock segments (event codes, EEG) with code tags and timestamp.</span>

<span class="sd">        Each row (1, n) in the epochs table is broadcast to an (m, n)</span>
<span class="sd">        array for the samples in the specified epochs interval and</span>
<span class="sd">        timestamps calculated for the anchor and match events.</span>

<span class="sd">        Epoch interval are extracted relative to the *matched* event</span>
<span class="sd">        in the code tag, see Yields for details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs_name : string</span>
<span class="sd">            name of epochs table Dataset in h5[&#39;epochs&#39;]</span>
<span class="sd">        columns : list of strings, default = None extracts all</span>
<span class="sd">            column names to extract</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        epoch : numpy structured array shape = (m, n + 2) where</span>

<span class="sd">           * m == `epoch_table[&#39;epoch_ticks&#39;]`, the length of the epoch in samples</span>

<span class="sd">           * n == the number of columns in `epoch_table`</span>

<span class="sd">           * the starting sample of the epoch is calculated relative to the</span>
<span class="sd">             *matched* event via `epoch_table[&#39;epoch_match_tick_delta&#39;]`</span>

<span class="sd">           * `epoch[:, column]` == `epoch_table[column]` for `column`</span>
<span class="sd">             in `epoch_table.dtype.names`. This broadcasts the</span>
<span class="sd">             experimental event code tags to all samples in the epoch.</span>

<span class="sd">           epoch[&#39;Time&#39;]: uint64</span>
<span class="sd">             epoch[&#39;Time&#39;] == 0  for the *matched* event</span>

<span class="sd">           epoch[&#39;anchor_time&#39;]: uint64</span>
<span class="sd">             epoch[&#39;anchor_time&#39;] == 0 for the *anchor* event</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>

<span class="sd">        Iterating over this generator will fetch all the epochs given</span>
<span class="sd">        in epochs_name</span>

<span class="sd">        .. TO DO: implement hdf5 region refs</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="n">epochs_path</span> <span class="o">=</span> <span class="s2">&quot;epochs/&quot;</span> <span class="o">+</span> <span class="n">epochs_name</span>
            <span class="n">epoch_view</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">epochs_path</span><span class="p">]</span>
            <span class="n">epoch_cols</span> <span class="o">=</span> <span class="n">epoch_view</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>

            <span class="c1"># guard against irregular epochs</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">epoch_view</span><span class="p">[</span><span class="s2">&quot;epoch_ticks&quot;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">epoch_view</span><span class="p">[</span><span class="s2">&quot;epoch_match_tick_delta&quot;</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epoch_view</span><span class="p">:</span>

                <span class="n">nsamp</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;epoch_ticks&quot;</span><span class="p">]</span>

                <span class="c1"># fill nsamp rows x event info columns</span>
                <span class="c1"># FIX ME ... subset columns here</span>
                <span class="n">event_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsamp</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># set for epoch slice</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="n">start_samp</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;match_tick&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;epoch_match_tick_delta&quot;</span><span class="p">]</span>
                <span class="n">stop_samp</span> <span class="o">=</span> <span class="n">start_samp</span> <span class="o">+</span> <span class="n">nsamp</span>
                <span class="n">epoch_streams</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_path&quot;</span><span class="p">]][</span><span class="n">start_samp</span><span class="p">:</span><span class="n">stop_samp</span><span class="p">]</span>

                <span class="c1"># upconvert EEG columns float16 to float32 b.c. 2 byte floats</span>
                <span class="c1"># fight w/ feather (unsupported datatype), MATLAB</span>
                <span class="c1"># (cannot co-mingle w/ int64)</span>
                <span class="n">f4_streams_dtype</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;float16&quot;</span><span class="p">:</span>
                        <span class="n">f4_streams_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;float32&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">f4_streams_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                        <span class="p">)</span>
                <span class="n">f4_streams_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">f4_streams_dtype</span><span class="p">)</span>
                <span class="n">epoch_streams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">epoch_streams</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">f4_streams_dtype</span><span class="p">)</span>

                <span class="c1"># merge epoch table, Time, and datablock stream table column names</span>
                <span class="n">all_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">event_info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
                <span class="n">all_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>  <span class="c1"># matched code timestamp</span>
                <span class="n">all_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;anchor_time&quot;</span><span class="p">)</span>  <span class="c1"># anchor code timestamp</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_cols</span><span class="p">:</span>
                        <span class="n">all_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

                <span class="c1"># use all available columns (default) or specified subset</span>
                <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">epoch_dt_names</span> <span class="o">=</span> <span class="n">all_cols</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_cols</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;column </span><span class="si">{0}</span><span class="s2"> not found in epoch table or data block: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">c</span>
                            <span class="p">)</span>
                            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">all_cols</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">epoch_dt_names</span> <span class="o">=</span> <span class="n">columns</span>

                <span class="c1"># ------------------------------------------------------------</span>
                <span class="c1"># ATTENTION: THIS SECTION IS HIGHLY PROCEDURAL AND BRITTLE</span>
                <span class="c1"># ------------------------------------------------------------</span>
                <span class="c1"># build data types</span>
                <span class="n">epoch_dt_types</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">epoch_dt_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">epoch_dt_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span> <span class="s2">&quot;anchor_time&quot;</span><span class="p">]:</span>
                        <span class="n">epoch_dt_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">epoch_dt_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event_info</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

                <span class="c1"># define dtype and initialize</span>
                <span class="n">epoch_dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">epoch_dt_names</span><span class="p">,</span> <span class="n">epoch_dt_types</span><span class="p">)))</span>
                <span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nsamp</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">epoch_dt</span><span class="p">))</span>

                <span class="c1"># take the stream names first to protect the time</span>
                <span class="c1"># varying columns, then propagate the new info from</span>
                <span class="c1"># the epoch event.</span>
                <span class="n">srate</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;dblock_srate&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">epoch_dt_names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">epoch_streams</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">epoch</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">epoch_streams</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;Time&quot;</span><span class="p">:</span>
                        <span class="n">epoch</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_samp2ms</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;match_tick&quot;</span><span class="p">],</span> <span class="n">srate</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_samp</span><span class="p">,</span> <span class="n">stop_samp</span><span class="p">)</span>
                        <span class="p">]</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="s2">&quot;anchor_time&quot;</span><span class="p">:</span>
                        <span class="n">epoch</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="nb">int</span><span class="p">(</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_samp2ms</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;anchor_tick&quot;</span><span class="p">],</span> <span class="n">srate</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_samp</span><span class="p">,</span> <span class="n">stop_samp</span><span class="p">)</span>
                        <span class="p">]</span>
                    <span class="k">elif</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">event_info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">epoch</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_info</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;uh oh ... unknown column </span><span class="si">{0}</span><span class="s2"> in epoch data extraction&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">n</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                <span class="c1"># ------------------------------------------------------------</span>

                <span class="k">yield</span> <span class="p">(</span><span class="n">epoch</span><span class="p">)</span>

<div class="viewcode-block" id="mkh5.get_epochs"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.get_epochs">[docs]</a>    <span class="k">def</span> <span class="nf">get_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epochs_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; fetch single trial epochs in tabluar form along </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs_name : str</span>
<span class="sd">            name of previously set epochs table</span>
<span class="sd">        format : str {&#39;numpy&#39;, &#39;pandas&#39;}</span>
<span class="sd">        columns : list of str or None {&#39;None&#39;}</span>
<span class="sd">            the subset of column names to extract</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : numpy.ndarray or pandas.DataFrame</span>
<span class="sd">           epochs.shape == (i x m, n + 2) where</span>

<span class="sd">           i = the number of epochs, indexed uniquely by epoch_table[&#39;Epoch_idx&#39;]</span>
<span class="sd">           m = epoch length in samples</span>
<span class="sd">           n = the number of columns in the `epochs_name` epochs table</span>

<span class="sd">          See `_h5_get_epochs()` for details.</span>

<span class="sd">        attrs : dict</span>
<span class="sd">           stub </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;numpy&quot;</span><span class="p">,</span> <span class="s2">&quot;pandas&quot;</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;format=&#39;numpy&#39; or format=&#39;pandas&#39; not </span><span class="si">{format}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5_get_epochs</span><span class="p">(</span><span class="n">epochs_name</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;pandas&quot;</span><span class="p">:</span>
            <span class="n">epochs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>

            <span class="c1"># cleanup bytestrings</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">epochs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># encode as utf8 or shrug and move on</span>
                    <span class="n">epochs</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;uncaught exception&quot;</span><span class="p">)</span>

        <span class="c1"># fetch the attrs for this epoch dataset</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">h5</span><span class="p">[</span><span class="s2">&quot;epochs&quot;</span><span class="p">][</span><span class="n">epochs_name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">epochs</span><span class="p">,</span> <span class="n">attrs</span></div>

<div class="viewcode-block" id="mkh5.export_epochs"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.export_epochs">[docs]</a>    <span class="k">def</span> <span class="nf">export_epochs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">epochs_name</span><span class="p">,</span> <span class="n">epochs_f</span><span class="p">,</span> <span class="n">file_format</span><span class="o">=</span><span class="s2">&quot;h5&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;write previously set epochs to data in specified file format</span>
<span class="sd">        </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        epochs_name : string</span>
<span class="sd">             must name one of the datasets in this h5[&#39;epochs&#39;]</span>
<span class="sd">        epochs_f : string</span>
<span class="sd">             file path and name of the data file</span>
<span class="sd">        file_format : string, {&#39;h5&#39;, &#39;feather&#39;, &#39;txt&#39;}</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>

<span class="sd">        * h5 format: the epochs are saved in the h5 file root a</span>
<span class="sd">          dataset named epochs_name. Fails if such a dataset already</span>
<span class="sd">          exists.</span>

<span class="sd">        * Output formats other than h5 overwrites any file with the</span>
<span class="sd">          same name without warning.</span>

<span class="sd">        * txt format is tab-separated. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;h5&quot;</span><span class="p">,</span> <span class="s2">&quot;feather&quot;</span><span class="p">,</span> <span class="s2">&quot;txt&quot;</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;uknown file_format=&#39;</span><span class="si">{0}</span><span class="s2">&#39;: must be &#39;h5&#39;, &#39;feather&#39;, or &#39;txt&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">file_format</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;h5&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_epochs</span><span class="p">(</span>
                <span class="n">epochs_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;numpy&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">epochs_f</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
                <span class="n">epochs_dataset</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">epochs_name</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">epochs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">epochs_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># non-hdf5 formats</span>
            <span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_epochs</span><span class="p">(</span>
                <span class="n">epochs_name</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;pandas&quot;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span>
            <span class="p">)</span>

            <span class="c1"># dump with pandas</span>
            <span class="k">if</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;feather&quot;</span><span class="p">:</span>
                <span class="n">epochs</span><span class="o">.</span><span class="n">to_feather</span><span class="p">(</span><span class="n">epochs_f</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">file_format</span> <span class="o">==</span> <span class="s2">&quot;txt&quot;</span><span class="p">:</span>
                <span class="c1"># don&#39;t write row count index</span>
                <span class="n">epochs</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">epochs_f</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span><span class="p">(</span>
                    <span class="s2">&quot;unknown file epoch export file format: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">file_format</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># PRIVATE (-ish) CRUD. These all wrap the hp5py.File()</span>
    <span class="c1"># in a context manager so user&#39;s don&#39;t have to.</span>
    <span class="c1"># ------------------------------------------------------------</span>

    <span class="c1"># data settin ops</span>
    <span class="c1"># def _h5_update_eeg_data(self, h5f, group_name, attr, data, yhdr, *args, **kwargs):</span>
    <span class="k">def</span> <span class="nf">_h5_update_eeg_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">h5f</span><span class="p">,</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;database-like CRUD to push .crw/.log data into the mkh5 format</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">          h5f : str</span>
<span class="sd">             filepath to existing writable h5, else h5py Error</span>
<span class="sd">  </span>
<span class="sd">          group_name : str</span>
<span class="sd">              h5 file Group path name</span>

<span class="sd">          header : mkh5.HeaderIO.header</span>
<span class="sd">              built from .crw header + YAML info</span>

<span class="sd">          data : numpy record array </span>
<span class="sd">              rows = samples </span>
<span class="sd">              columns = ticks, events, log, individual channel data</span>

<span class="sd">          yhdr : dict</span>
<span class="sd">              contains supplemental information from yaml file (see</span>
<span class="sd">             `_load_yhdr`) args (stub) kwargs = passed to</span>

<span class="sd">          *args, **kwargs</span>
<span class="sd">             passed to h5py, e.g., compression, chunks</span>

<span class="sd">        Warning: When appending data to existing data headers are not</span>
<span class="sd">        checked for consistency`</span>

<span class="sd">        Use case 1: Create/New. This is the basic step to convert</span>
<span class="sd">        .crw/.log to the mkh5 data interchange format.</span>

<span class="sd">        Use case 2: Update/Append.  This behavior combines .crw/.log</span>
<span class="sd">        files to add cals, recover from restarts, combine sessions and</span>
<span class="sd">        such.</span>

<span class="sd">        Implementation:</span>

<span class="sd">        * mkio returns log info and the eeg strip chart incrementally</span>
<span class="sd">          indexed by A/D sample, ie., crw_ticks = 0 ... number of</span>
<span class="sd">          samples. This EEG data array is split on negative crw event</span>
<span class="sd">          code rows (pauses, data errors) into mkh5 datablocks of</span>
<span class="sd">          continuously sampled eeg.</span>

<span class="sd">        * The mkh5 datablock is the minimal unit, consisting of </span>

<span class="sd">           * dblock_N (h5py.Dataset) a single numpy.ndarray log + eeg</span>
<span class="sd">                      stripchart</span>

<span class="sd">           * dblock_N.attr[json_header] (h5py.Attribute) the log + eeg</span>
<span class="sd">                      header information encoded as a JSON string. </span>

<span class="sd">        * The processing to Create and Append .crw/.log as mkh5 datablocks is</span>
<span class="sd">          identical</span>

<span class="sd">          - count the number of existing datablocks in h5_path = N</span>
<span class="sd">          - create sequentially numbered datablocks at h5_path starting with N</span>

<span class="sd">        For Create/New, N == 0</span>

<span class="sd">        For Append N &gt; 0</span>

<span class="sd">          group/dblock_n, group/dblock_n+1, ... group/dblock_n+m+m</span>

<span class="sd">        mkh5 datablock format: dblock_N</span>

<span class="sd">           Each continuous record is a new, sequentially</span>
<span class="sd">           numbered recording h5py.Group under input group_name.</span>

<span class="sd">           Under each such recording, each column in data is a new dataset.</span>

<span class="sd">           group_name/dblock_0/crw_ticks</span>
<span class="sd">           group_name/dblock_0/raw_evcodes</span>
<span class="sd">           ... </span>
<span class="sd">           group_name/dblock_0/lle</span>
<span class="sd">           group_name/dblock_0/lhz</span>
<span class="sd">           ...</span>
<span class="sd">           group_name/dblock_0/MiPa</span>
<span class="sd">           ...</span>
<span class="sd">           group_name/dblock_0/the_last_channel</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># 1. collect the boundaries of the continuous stretchs of .crw</span>
        <span class="c1"># data at</span>
        <span class="c1">#</span>
        <span class="c1">#   - beginning</span>
        <span class="c1">#   - negative event codes = pauses, data errors</span>
        <span class="c1">#   - end</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="n">negative_raw_code_idxs</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># white list pause mark codes for the dblock boundaries</span>
        <span class="n">pause_idxs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">i</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">negative_raw_code_idxs</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_dig_pause_marks</span>
        <span class="p">]</span>

        <span class="c1"># negative log codes are common, negative raw codes other than</span>
        <span class="c1"># pause marks are not</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">negative_raw_code_idxs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pause_idxs</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="s2">&quot;raw tick </span><span class="si">{0}</span><span class="s2">: code </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">negative_raw_code_idxs</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_dig_pause_marks</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> unusual negative codes in raw marktrack ... &quot;</span>
                <span class="s2">&quot;make sure you know why.&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5f</span><span class="p">,</span> <span class="n">group_name</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">data_boundaries</span> <span class="o">=</span> <span class="p">[</span>
            <span class="o">-</span><span class="mi">1</span>
        <span class="p">]</span>  <span class="c1"># start with a boundary one sample before the first, i.e., at -1</span>
        <span class="n">data_boundaries</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pause_idxs</span><span class="p">)</span>  <span class="c1"># add the boundaries</span>

        <span class="c1"># force a boundary at the last sample in case the file was closed without pausing</span>
        <span class="n">datalen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">data_boundaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">datalen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data_boundaries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_boundaries</span><span class="p">,</span> <span class="n">datalen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;no pause mark at the last data sample ... make sure this is OK&quot;</span>
            <span class="p">)</span>

        <span class="c1"># (start, stop) tuples of data block row indices</span>
        <span class="n">data_intervals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">data_boundaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_boundaries</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_boundaries</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># build the h5 datasets and set their header attr</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5f</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="c1"># find and count datablocks already in the group</span>
            <span class="n">dblock_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">h5</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;dblock&quot;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">nextblock</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dblock_ids</span><span class="p">)</span>  <span class="c1"># for the dblock_id counter</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_intervals</span><span class="p">):</span>

                <span class="c1"># split data into on the interval tuples</span>
                <span class="n">dblock_id</span><span class="p">,</span> <span class="n">dblock</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

                <span class="c1"># ------------------------------------------------------------</span>
                <span class="c1"># write the dig data chunk as dblock_N</span>
                <span class="c1"># ------------------------------------------------------------</span>
                <span class="n">dblock_id</span> <span class="o">=</span> <span class="s2">&quot;dblock_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nextblock</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">dblock</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                    <span class="n">dblock_id</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">][</span><span class="n">start</span> <span class="p">:</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="c1"># set this dblock ticks sequence</span>
                <span class="n">dblock</span><span class="p">[</span><span class="s2">&quot;dblock_ticks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">((</span><span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

                <span class="c1"># set this dblock header</span>
                <span class="n">header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dblock</span><span class="p">)</span>

            <span class="c1"># FIX ME: sanity check the data blocks samples total to data samples</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># *** PUBLIC *** CRUD</span>
    <span class="c1"># ------------------------------------------------------------</span>
<div class="viewcode-block" id="mkh5.reset_all"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.reset_all">[docs]</a>    <span class="k">def</span> <span class="nf">reset_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;completely wipe out the mkh5 file and reset to empty without mercy&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="c1"># version new h5 files</span>
            <span class="n">h5</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">__version__</span></div>

    <span class="c1"># create a new data set in specified group</span>
<div class="viewcode-block" id="mkh5.create_mkdata"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.create_mkdata">[docs]</a>    <span class="k">def</span> <span class="nf">create_mkdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">,</span> <span class="n">eeg_f</span><span class="p">,</span> <span class="n">log_f</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convert Kutas lab ERPSS `.crw` and `.log` to the </span>
<span class="sd">        `mkh5` hdf5 format.</span>

<span class="sd">        This is the analog of ERPSS `dig` program both create new</span>
<span class="sd">        EEG + header + log data files, albeit in different formats. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_path : string</span>
<span class="sd">             The full slashpath location in the `.h5` file where the</span>
<span class="sd">             new data blocks will be stored in the hdf5 file. Must be</span>
<span class="sd">             the full slashpath from the root without the leading</span>
<span class="sd">             slash.</span>
<span class="sd">        eeg_f : string</span>
<span class="sd">             file path to the `.crw` files.</span>
<span class="sd">        log_f : string</span>
<span class="sd">             file path to corresponding `.log` file.</span>
<span class="sd">        yhdr_f : string</span>
<span class="sd">             path to the YAML header file.</span>
<span class="sd">        *args : strings, optional</span>
<span class="sd">            passed in to `h5py.create_dataset()`</span>
<span class="sd">        *kwargs : key=values, optional</span>
<span class="sd">            passed in to `h5py.create_dataset()`, e.g., </span>
<span class="sd">            `compression=&quot;gzip&quot;`.</span>

<span class="sd">  </span>
<span class="sd">        Nathaniel Smith did all the hard work of low level ERPSS file</span>
<span class="sd">        IO.</span>

<span class="sd">        Uncompressed ERPSS `.raw` files are also legal but there is no</span>
<span class="sd">        good reason to have them around. If the raw won&#39;t compress</span>
<span class="sd">        because it is defective it won&#39;t convert to `mkh5` either.</span>
<span class="sd">        there are no useful `**kwargs`. Chunking fails when the</span>
<span class="sd">        size of datablock is smaller than the chunk and</span>
<span class="sd">        compression makes files a little smaller and a lot slower</span>
<span class="sd">        to read/write.</span>

<span class="sd">        The EEG and event code data streams are snipped apart into</span>
<span class="sd">        uninterrupted &quot;datablocks&quot; at pause marks. Each data block has</span>
<span class="sd">        its own header containing information from the `.crw` file</span>
<span class="sd">        merged with the additional information from the YAML header</span>
<span class="sd">        file `yhdr_f`.</span>


<span class="sd">        Examples</span>

<span class="sd">        .. todo::</span>
<span class="sd">           Give examples or link to snippets or examples</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># clean up Path</span>
        <span class="n">eeg_f</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">eeg_f</span><span class="p">)</span>
        <span class="n">log_f</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">log_f</span><span class="p">)</span>
        <span class="n">yhdr_f</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">yhdr_f</span><span class="p">)</span>

        <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_raw_log</span><span class="p">(</span><span class="n">eeg_f</span><span class="p">,</span> <span class="n">log_f</span><span class="p">)</span>

        <span class="n">hio</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
        <span class="n">hio</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">)</span>  <span class="c1"># merge the .crw and yhdr into the new header</span>

        <span class="c1"># create the group and write the header</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># create with data ... data.dtype is automatic</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">h5</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">h5_path</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">fail</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mkh5 path </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5_path</span><span class="p">))</span>
                <span class="k">raise</span> <span class="n">fail</span>

        <span class="c1"># write out the data into hdf5 datablocks+attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5_update_eeg_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">,</span> <span class="n">hio</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># FIX ME</span>
        <span class="c1"># self._check_data()</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># add eeg data to a group under the same header</span>
    <span class="c1"># ------------------------------------------------------------</span>
<div class="viewcode-block" id="mkh5.append_mkdata"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.append_mkdata">[docs]</a>    <span class="k">def</span> <span class="nf">append_mkdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">,</span> <span class="n">eeg_f</span><span class="p">,</span> <span class="n">log_f</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append .crw, .log, .yhdr to an existing h5_path</span>

<span class="sd">        This function extend an existing sequence of datablocks</span>
<span class="sd">        `h5_path/dblock_0`, ... `h5_path/dblock_N`, with the</span>
<span class="sd">        continuation, `h5_path/dblock_N+1`, ... </span>

<span class="sd">        The intended applicaton is to combine `.crw`, `.log` files</span>
<span class="sd">        together that could or should be grouped, e.g., to add</span>
<span class="sd">        separately recorded cals, recover from dig crashes, to pool an </span>
<span class="sd">        individuals data recorded in different sessions. </span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_path : string</span>
<span class="sd">             The full slashpath location in the `.h5` file where the</span>
<span class="sd">             new data blocks will be stored in the hdf5 file. Must be</span>
<span class="sd">             the full slashpath from the root without the leading</span>
<span class="sd">             slash.</span>
<span class="sd">        eeg_f : string</span>
<span class="sd">             file path to the `.crw` files.</span>
<span class="sd">        log_f : string</span>
<span class="sd">             file path to corresponding `.log` file.</span>
<span class="sd">        yhdr_f : string</span>
<span class="sd">             path to the YAML header file.</span>
<span class="sd">        </span>

<span class="sd">        Raises</span>
<span class="sd">        -------</span>
<span class="sd">        Warning</span>
<span class="sd">             If the new crw headers do not match the existing</span>
<span class="sd">             group attributes</span>


<span class="sd">        See Also</span>
<span class="sd">        ---------</span>
<span class="sd">        :meth:`~mkpy.mkh5.mkh5.create_mkdata`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># clean up Path</span>
        <span class="n">eeg_f</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">eeg_f</span><span class="p">)</span>
        <span class="n">log_f</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">log_f</span><span class="p">)</span>
        <span class="n">yhdr_f</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">yhdr_f</span><span class="p">)</span>

        <span class="c1"># slurp crw/log</span>
        <span class="p">(</span><span class="n">crw_hdr</span><span class="p">,</span> <span class="n">crw_data</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_raw_log</span><span class="p">(</span><span class="n">eeg_f</span><span class="p">,</span> <span class="n">log_f</span><span class="p">)</span>

        <span class="c1"># build the new header</span>
        <span class="n">new_hio</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
        <span class="n">new_hio</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">crw_hdr</span><span class="p">,</span> <span class="n">yhdr_f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_h5_update_eeg_data</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">,</span> <span class="n">new_hio</span><span class="p">,</span> <span class="n">crw_data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.delete_mkdata"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.delete_mkdata">[docs]</a>    <span class="k">def</span> <span class="nf">delete_mkdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;delete a top-level group from the mkh5 h5 file without warning, see Notes about wasted space.</span>

<span class="sd">        Parameters</span>

<span class="sd">        sub_id (string) path to h5 group in the instance&#39;s h5file</span>

<span class="sd">        Notes:</span>

<span class="sd">        Use sparingly or not at all. hdf5 has no garbage collection,</span>
<span class="sd">        deleting groups leaves holes in the file unless the entire</span>
<span class="sd">        file tree is copied to a fresh file</span>

<span class="sd">        FIX ME: hdf5 notes hack around no garbage collection is to</span>
<span class="sd">        rewrite the gappy file to a new file ... this could be built</span>
<span class="sd">        in here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="c1"># with data ... data.dtype is automatic</span>
            <span class="k">del</span> <span class="n">h5</span><span class="p">[</span><span class="n">sub_id</span><span class="p">]</span></div>

    <span class="c1"># FIX ME, this can call _h5_get_dblock_slice</span>
<div class="viewcode-block" id="mkh5.get_dblock"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.get_dblock">[docs]</a>    <span class="k">def</span> <span class="nf">get_dblock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a copy of header dict and numpy ndarray from the mkh5</span>
<span class="sd">        datablock at h5_path</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_path : string</span>
<span class="sd">          full slashpath to a datablock in this mkh5 instance</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
            <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">h5_path</span><span class="p">])</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span>
            <span class="c1"># dblock = copy.deepcopy(h5[h5_path].value) # deprecated</span>
            <span class="n">dblock</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">h5_path</span><span class="p">][</span><span class="o">...</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">dblock</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_h5_get_dblock_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_f</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">,</span> <span class="n">db_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return a copy of header dict and numpy ndarray slice from the mkh5</span>
<span class="sd">        datablock from h5 file at h5_path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_f : string</span>
<span class="sd">           path to mkh5 file</span>
<span class="sd">        h5_path : string</span>
<span class="sd">          full slashpath to a datablock in this mkh5 instance</span>
<span class="sd">        db_slice : slice (default = None)</span>
<span class="sd">          rows slice of the dblock to return, None returns entire dblock</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (hdr, dblock_slice) : dict, np.ndarray</span>
<span class="sd">           entire dblock header dict for and the slice of dblock data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_f</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>

            <span class="c1"># db_len = len(h5[h5_path].value)</span>
            <span class="n">db_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">h5_path</span><span class="p">][</span><span class="o">...</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">db_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">db_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">db_len</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">db_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;data block slice start &lt; 0&quot;</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">db_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">&gt;</span> <span class="n">db_len</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;data block slice stop &gt; data block length&quot;</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
            <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">h5_path</span><span class="p">])</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span>
            <span class="n">dblock_slice</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">h5_path</span><span class="p">][</span><span class="n">db_slice</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">dblock_slice</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># PUBLIC utilities</span>
    <span class="c1"># ------------------------------------------------------------</span>
<div class="viewcode-block" id="mkh5.headinfo"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.headinfo">[docs]</a>    <span class="k">def</span> <span class="nf">headinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="s2">&quot;.+&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;print header information matching the pattern regular expression to STDOUT</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pattern: regexp </span>
<span class="sd">           regular expression to look for in the slashpaths to</span>
<span class="sd">           datablocks and header information in this mkh5 format</span>
<span class="sd">           file. Default &#39;.+&#39; matches all header info.</span>


<span class="sd">        Assume we have previously constructed an mkh5 file `expts.h5`</span>
<span class="sd">        containing data for two experiments and multiple subjects in</span>
<span class="sd">        each and decorated with yaml header information about</span>
<span class="sd">        electrode locations.</span>

<span class="sd">        We may want to query and display more or less header</span>
<span class="sd">        information. Usually less since there is lots.</span>

<span class="sd">        Select the relevant information with regular expression</span>
<span class="sd">        pattern matching:</span>
<span class="sd">        </span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">           &gt; expts = mkh5.mkh5(&#39;expts.h5&#39;) # initialize the mkh5 object</span>
<span class="sd">           &gt; expts.headinfo(&#39;Expt1/S001&#39;) # fetch all header info for Expt1/S001, all datablocks</span>
<span class="sd">           &gt; expts.headinfo(&#39;Expt1/.*MiPa&#39;) # returns everything in any Expt1 header involving MiPa</span>
<span class="sd">           &gt; expts.headinfo(&#39;Expt1/S001/apparatus/space/origin&#39;) # origin of sensor space Expt1/S003 </span>
<span class="sd">           &gt; expts.headinfo(&#39;Expt1/S001/apparatus/sensors/MiPa/x&#39;) # x-coordinate of electrode MiPa</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_head</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;headinfo pattern </span><span class="si">{0}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pattern</span><span class="p">))</span></div>

<div class="viewcode-block" id="mkh5.sethead"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.sethead">[docs]</a>    <span class="k">def</span> <span class="nf">sethead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slash_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;update mkh5 dblock header information via ``dpath.utils`` style </span>
<span class="sd">        slash path, value notation.</span>


<span class="sd">        The recommended method for adding information to mkh5 headers</span>
<span class="sd">        is via the YAML header file loaded when converting .crw/.log</span>
<span class="sd">        to mkh5</span>
<span class="sd">        </span>
<span class="sd">        myh5file.create_mkdata(&#39;my.crw&#39;, &#39;my.log&#39;, &#39;my.yhdr&#39;) </span>

<span class="sd">        Use sethead() at your own risk. mucking with headers by hand</span>
<span class="sd">        is dangerous without a clear understanding of the mkh5 dataset</span>
<span class="sd">        and header attribute format and dpath.util behavior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        slash_vals : (str, value) 2-ple or list of them</span>
<span class="sd">           str is a slash path to an mkh5 dblock and on into the header</span>
<span class="sd">           value is JSON-ifiable scalar, dict, or sequence</span>



<span class="sd">        .. code-block:: python</span>

<span class="sd">          mydat = mkh5.mkh5(&#39;myfile.h5&#39;)</span>
<span class="sd">          mydat.sethead((&#39;S01/dblock_0/long_subid&#39;, &#39;S0001_A&#39;)</span>

<span class="sd">          # probably a bad idea to set this only for first datablock</span>
<span class="sd">          mydat.sethead((&#39;S01/dblock_0/npsych/mood_score&#39;, 4)</span>
<span class="sd">         </span>
<span class="sd">          # use a list to set for all dblocks</span>
<span class="sd">          spvs = [(&#39;S01/dblock_0/npsych/mood_score&#39;, 4),</span>
<span class="sd">                  (&#39;S01/dblock_1/npsych/mood_score&#39;, 4),</span>
<span class="sd">                  (&#39;S01/dblock_2/npsych/mood_score&#39;, 4),</span>
<span class="sd">                  (&#39;S01/dblock_3/npsych/mood_score&#39;, 4),</span>
<span class="sd">                  (&#39;S01/dblock_4/npsych/mood_score&#39;, 4),</span>
<span class="sd">                   (&#39;S01/dblock_5/npsych/mood_score&#39;, 4), ]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># organize the input list of slash_vals by mkh5 datablock</span>
        <span class="n">by_dblock</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">path</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">slash_vals</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.+/dblock_\d+)/(.+)&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">h5_dblock_path</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">h5_header_path</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">h5_dblock_path</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">by_dblock</span><span class="p">:</span>
                    <span class="n">by_dblock</span><span class="p">[</span><span class="n">h5_dblock_path</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># first time thru</span>
                <span class="n">by_dblock</span><span class="p">[</span><span class="n">h5_dblock_path</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">h5_header_path</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

        <span class="c1"># iterate by the dblocks found and update</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">h5_dblock_path</span><span class="p">,</span> <span class="n">hdr_slash_vals</span> <span class="ow">in</span> <span class="n">by_dblock</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_h5_update_header</span><span class="p">(</span>
                    <span class="n">h5</span><span class="p">[</span><span class="n">h5_dblock_path</span><span class="p">],</span> <span class="n">hdr_slash_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span></div>

<div class="viewcode-block" id="mkh5.gethead"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.gethead">[docs]</a>    <span class="k">def</span> <span class="nf">gethead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; get header values as a list of (slashpath, value) 2-ples suitable for passing to edhead&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_head</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span></div>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># introspection: headinfo and info</span>
    <span class="c1"># ------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetch all mkh5 dblock header info matching slashpath regexp pattern</span>

<span class="sd">        Parameters:</span>

<span class="sd">        pattern (regexp string) pattern to look for in the mkh5 headers</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        matches : list</span>
<span class="sd">          list of 2-ples (slashpath, value)</span>

<span class="sd">        Example</span>

<span class="sd">        mydat._get_head(&#39;S0/dblock_0/streams/(crw_ticks|MiPa)&#39;)</span>

<span class="sd">        [</span>
<span class="sd">          (S01/dblock_0/streams/crw_ticks/jdx, 1),</span>
<span class="sd">          (S01/dblock_0/streams/crw_ticks/stream, &#39;new_crw_ticks&#39;),</span>
<span class="sd">          (S01/dblock_0/streams/crw_ticks/name, &#39;crw_ticks&#39;),</span>
<span class="sd">          (S01/dblock_0/streams/crw_ticks/dt, &#39;&lt;u4&#39;),</span>
<span class="sd">          (S01/dblock_0/streams/MiPa/jdx, 22),</span>
<span class="sd">          (S01/dblock_0/streams/MiPa/stream, &#39;eeg0016&#39;),</span>
<span class="sd">          (S01/dblock_0/streams/MiPa/name, &#39;MiPa&#39;),</span>
<span class="sd">          (S01/dblock_0/streams/MiPa/dt, &#39;&lt;f2&#39;)</span>
<span class="sd">        ]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="n">h5_paths</span> <span class="o">=</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_data_group_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">)</span>
        <span class="n">db_slashpaths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">h5_paths</span><span class="p">:</span>
            <span class="n">db_slashpaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h5tools</span><span class="o">.</span><span class="n">get_dblock_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">db_slashpath</span> <span class="ow">in</span> <span class="n">db_slashpaths</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dbs</span> <span class="ow">in</span> <span class="n">db_slashpath</span><span class="p">:</span>
                    <span class="n">hio</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
                    <span class="p">)</span>  <span class="c1"># abundance of caution we are starting fresh</span>
                    <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">dbs</span><span class="p">])</span>
                    <span class="n">hdr_paths</span> <span class="o">=</span> <span class="n">dpath</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">paths</span><span class="p">(</span>
                        <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">dirs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">leaves</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">hdr_path</span> <span class="ow">in</span> <span class="n">hdr_paths</span><span class="p">:</span>
                        <span class="n">slash_path</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hdr_path</span><span class="p">])</span>
                        <span class="n">full_path</span> <span class="o">=</span> <span class="n">dbs</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">slash_path</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">full_path</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                            <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">(</span>
                                    <span class="n">full_path</span><span class="p">,</span>
                                    <span class="n">dpath</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">hdr_path</span><span class="p">),</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">del</span> <span class="n">hio</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">matches</span>

<div class="viewcode-block" id="mkh5.info"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;return h5dump-ish overview of h5_path&#39;s groups/datasets/attributes and data</span>
<span class="sd">        Parameter:</span>
<span class="sd">      </span>
<span class="sd">        h5_path (string) h5 path to a group or dataset </span>

<span class="sd">        Returns info (string) </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># headinfo = self.headinfo(**kwargs)</span>
        <span class="n">headinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_head</span><span class="p">(</span><span class="s2">&quot;.+&quot;</span><span class="p">)</span>
        <span class="n">h5_paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.*dblock_\d+&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">headinfo</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">h5_paths</span><span class="p">:</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;------------------------------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
                    <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;datablock attributes:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">hdr_slash_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_head</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">db_headinfo</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="p">[</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hdr_slash_vals</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">info</span> <span class="o">+=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="n">db_headinfo</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">80</span><span class="p">)</span>
                    <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;Data: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="o">...</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;  </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                        <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;  </span><span class="si">{0}</span><span class="s2"> .. </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">col</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">col</span><span class="p">][</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span>
                        <span class="p">)</span>
                        <span class="n">mqm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">col</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
                        <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot; min-q-max: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mqm</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Group</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;unknown h5py type: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">h5</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
                    <span class="p">)</span>
                <span class="n">info</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">info</span></div>

<div class="viewcode-block" id="mkh5.calibrate_mkdata"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.calibrate_mkdata">[docs]</a>    <span class="k">def</span> <span class="nf">calibrate_mkdata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_name</span><span class="p">,</span>
        <span class="n">cal_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polarity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lo_cursor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hi_cursor</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span>
        <span class="n">n_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cal_ccode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_cals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;fetch and apply normerp style calibration to raw/crw dataset. </span>

<span class="sd">        This locates two cursors, one on either side of a an</span>
<span class="sd">        event-triggered calibration square wave step and measures</span>
<span class="sd">        average values in the interval +/- n_points around the cursors</span>
<span class="sd">        separately at each EEG data stream. The magnitude of the</span>
<span class="sd">        difference is the measure of the step. The calibration scaling</span>
<span class="sd">        factor for that stream is the average of the (trimmed)</span>
<span class="sd">        calibration pulses.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        id_name : str</span>
<span class="sd">            h5 group name that is parent to mkpy format dblocks, id_name/dblocks</span>
<span class="sd">        cal_size : float</span>
<span class="sd">            magnitude of calibration square wave step in microvolts, e.g., 10</span>
<span class="sd">        polarity : (1,0) </span>
<span class="sd">            ignored, and should be deprecated. In ERPSS this inverts</span>
<span class="sd">            all waveforms ... has nothing to do with calibration really.</span>
<span class="sd">        lo_cursor: float (positive value)</span>
<span class="sd">            magnitude of the low cursor offset from the calibration</span>
<span class="sd">            event in milliseconds</span>
<span class="sd">        hi_cursor: float (positive value)</span>
<span class="sd">            magnitude of the high cursor offset from the calibration</span>
<span class="sd">            event in milliseconds</span>
<span class="sd">        n_points : uint</span>
<span class="sd">            number of points on either side of each cursor to measure,</span>
<span class="sd">            interval = 2*n_points + 1</span>
<span class="sd">        cal_ccode : uint (default = 0)</span>
<span class="sd">            search for cal pulses only in dblocks where the ccode</span>
<span class="sd">            column == cal_ccode.  The standing kutas lab convention is</span>
<span class="sd">            cal ccode == 0</span>
<span class="sd">        use_cals : str (None defaults to `id_name`)</span>
<span class="sd">            slashpath to an alternate h5 group containing dblocks with the cal pulses</span>
<span class="sd">        use_file : str (None defaults to `self.f_name`)</span>
<span class="sd">            slashpath to an alternate mkpy format h5 data file.</span>


<span class="sd">        1. Calibration pulses are often recorded into the same `.crw`</span>
<span class="sd">           file or a separate file following data acquisition and then</span>
<span class="sd">           mkh5.append()-ed to a group. In both cases, the cal pulses</span>
<span class="sd">           appear in dblocks sister to the EEG data they are used to</span>
<span class="sd">           calibrate.</span>

<span class="sd">           Consequently the default calibration behavior is to search</span>
<span class="sd">           the dblocks daughter to self.h5_fname/id_name for the cal</span>
<span class="sd">           pulses.</span>

<span class="sd">           In rare cases, cal pulses are missing entirely and must be</span>
<span class="sd">           poached from another data group in the same hdf5 file or a</span>
<span class="sd">           data group in a different hdf5 file.</span>

<span class="sd">           Setting `use_cals` overrides the default group name.</span>

<span class="sd">           Setting `use_file` overrides the default self.f_name.</span>

<span class="sd">        2. The normerp way is to use the *ABSOLUTE VALUE* of the cal</span>
<span class="sd">           step regardless of polarity to adjust the amplitude of the</span>
<span class="sd">           +/- A/D recordings ... leaving the sign unchanged.</span>
<span class="sd">        </span>
<span class="sd">        3. The polarity flag -1 is used *ONLY* to switch the sign of</span>
<span class="sd">           the EEG and has nothing to do with the A/D scaling factor</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># FIX ME: FINISH INPUT ERROR CHECK</span>
        <span class="c1"># FIX ME: this should throw future warning and be deprecated</span>
        <span class="k">if</span> <span class="n">polarity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">polarity</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;polarity == -1 ... this is not necessary for negative cals and probably wrong.&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Use it only to invert the polarity of the EEG recording for some bizzare reason like&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;amps configured backwards with A1 (+) and Cz (-) instead of the usual Cz (+) and A1(-)&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">polarity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;polarity flag must be 1 to leave EEG polarity unchanged or -1 to switch the sign&quot;</span>
            <span class="p">)</span>

        <span class="c1"># where to look for cals?</span>
        <span class="k">if</span> <span class="n">use_cals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_cals</span> <span class="o">=</span> <span class="n">id_name</span>  <span class="c1"># default is daughter dblocks</span>

        <span class="k">if</span> <span class="n">use_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span>  <span class="c1"># default is same mkpy file</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">use_cals</span><span class="p">,</span> <span class="n">use_file</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Calibrating </span><span class="si">{0}</span><span class="s2"> using cals from </span><span class="si">{1}</span><span class="s2">/</span><span class="si">{2}</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">id_name</span><span class="p">,</span> <span class="n">use_cals</span><span class="p">,</span> <span class="n">use_file</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># fetch a cal_info bundle from the use_cals group</span>
        <span class="c1"># ... cal_pulses are for inspection/plotting</span>
        <span class="n">cal_info</span><span class="p">,</span> <span class="n">cal_pulses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5_get_calinfo</span><span class="p">(</span>
            <span class="n">use_file</span><span class="p">,</span>
            <span class="n">use_cals</span><span class="p">,</span>
            <span class="n">cal_size</span><span class="o">=</span><span class="n">cal_size</span><span class="p">,</span>
            <span class="n">lo_cursor</span><span class="o">=</span><span class="n">lo_cursor</span><span class="p">,</span>
            <span class="n">hi_cursor</span><span class="o">=</span><span class="n">hi_cursor</span><span class="p">,</span>
            <span class="n">n_points</span><span class="o">=</span><span class="n">n_points</span><span class="p">,</span>
            <span class="n">cal_ccode</span><span class="o">=</span><span class="n">cal_ccode</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># FIX ME .. .implement min_cal_count ???</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>
            <span class="c1"># datablock refs</span>
            <span class="c1"># n_dblocks = len([k for k in h5[id_name].keys() if &#39;dblock&#39; in k])</span>
            <span class="c1"># dblocks = [h5[id_name + &#39;/&#39; + &#39;dblock_&#39;+ str(i)] for i in range(n_dblocks)]</span>

            <span class="n">dblock_paths</span> <span class="o">=</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_dblock_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">id_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dblock_path</span> <span class="ow">in</span> <span class="n">dblock_paths</span><span class="p">:</span>

                <span class="n">dblock</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">dblock_path</span><span class="p">]</span>
                <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
                <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dblock</span><span class="p">)</span>
                <span class="n">is_calibrated</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="s2">&quot;cal&quot;</span> <span class="ow">in</span> <span class="n">key</span>
                        <span class="k">for</span> <span class="n">stream</span> <span class="ow">in</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">][</span><span class="n">stream</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_calibrated</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> CAUTION skipping &quot;</span>
                        <span class="o">+</span> <span class="n">dblock_path</span>
                        <span class="o">+</span> <span class="s2">&quot; ... appears to be already calibrated&quot;</span>
                    <span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Calibrating block </span><span class="si">{0}</span><span class="s2"> of </span><span class="si">{1}</span><span class="s2">: </span><span class="si">{2}</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">dblock</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dblock_paths</span><span class="p">),</span> <span class="n">dblock</span><span class="o">.</span><span class="n">shape</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="c1"># get the names of colums with streams that string match &#39;dig_chan_&#39; from attr metadata</span>
                <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
                <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dblock</span><span class="p">)</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span>
                <span class="n">strms</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">]</span>

                <span class="c1"># fail if chan names don&#39;t match</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cal_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">k</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">strms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="s2">&quot;dig_chan_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
                    <span class="p">]</span>
                <span class="p">):</span>
                    <span class="n">calchans</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cal_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Calibration datablock </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">use_cals</span><span class="p">,</span> <span class="n">calchans</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;This data block </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">dblock</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">chan_names</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;channel names in calibration data do not match data columns&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># walk the cal info and apply it to this data ...</span>
                <span class="c1"># dt_uV = np.dtype(np.dtype([(&#39;uV&#39;,mkh5._mk_EEG)]))</span>
                <span class="n">cal_slash_vals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of new attributes</span>
                <span class="k">for</span> <span class="n">chan</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">cal_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># print(&#39;  {0}&#39;.format(chan), end=&#39;&#39;)</span>
                    <span class="c1"># dblock[chan] = dblock[chan]*(float(cal_size)/float(info[&#39;scale_by&#39;]))</span>
                    <span class="c1"># The normerp way ... scale by positive magnitude of cal step regardless</span>
                    <span class="c1"># of its sign.</span>
                    <span class="n">scale_by</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">scale_by</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;scale_by&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">scale_by</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="s2">&quot;FYI found negative cal pulses </span><span class="si">{0}</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> ... &quot;</span>
                            <span class="s2">&quot;calibration will be OK&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dblock_path</span><span class="p">,</span> <span class="n">chan</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="n">scale_by</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">scale_by</span><span class="p">)</span>

                    <span class="c1"># access by column *NAME*</span>
                    <span class="n">dblock</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="n">dblock</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cal_size</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale_by</span><span class="p">)</span>

                    <span class="c1"># This is pointless when the data are loaded into python</span>
                    <span class="k">if</span> <span class="n">polarity</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">dblock</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">dblock</span><span class="p">[</span><span class="n">chan</span><span class="p">]</span>

                    <span class="c1"># record this in the channel_metatdata</span>
                    <span class="c1"># chan_jdx = chan_jdxs[chan_names.index(chan)] # list version</span>
                    <span class="c1"># self._h5_set_dblock_attrs(dblock, streams=[(chan_jdx, &#39;calibrated&#39;, True),</span>
                    <span class="c1">#                                           (chan_jdx, &#39;cals&#39;, info)])</span>
                    <span class="c1"># chan_jdx = strms[chan][&#39;jdx&#39;] # dict version</span>
                    <span class="n">cal_slash_vals</span> <span class="o">+=</span> <span class="p">[</span>
                        <span class="p">(</span><span class="s2">&quot;streams/&quot;</span> <span class="o">+</span> <span class="n">chan</span> <span class="o">+</span> <span class="s2">&quot;/calibrated&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">cal_slash_vals</span> <span class="o">+=</span> <span class="p">[(</span><span class="s2">&quot;streams/&quot;</span> <span class="o">+</span> <span class="n">chan</span> <span class="o">+</span> <span class="s2">&quot;/cals&quot;</span><span class="p">,</span> <span class="n">info</span><span class="p">)]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_h5_update_header</span><span class="p">(</span><span class="n">dblock</span><span class="p">,</span> <span class="n">cal_slash_vals</span><span class="p">)</span></div>
                <span class="c1"># self._h5_update_header(dblock, [(&#39;streams/&#39; + chan + &#39;/calibrated&#39;, True),</span>
                <span class="c1">#                              (&#39;streams/&#39; + chan + &#39;/cals&#39;, info)]</span>

    <span class="k">def</span> <span class="nf">_attr_to_slashpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; walk dictionary building a list of dpath friendly slashpaths, e.g., dblock.attr dicts&quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">k</span>  <span class="c1"># last key</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># l.append(&#39;{0}: {1}&#39;.format(p, v))</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="c1"># print(leaf)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_attr_to_slashpath</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_data_group_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">h5_paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_groups</span>
        <span class="k">for</span> <span class="n">h5_path</span> <span class="ow">in</span> <span class="n">h5_paths</span><span class="p">:</span>
            <span class="n">data_blocks</span> <span class="o">+=</span> <span class="n">h5tools</span><span class="o">.</span><span class="n">get_dblock_paths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">h5_path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_blocks</span>

    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">_load_eeg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eeg_f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;kutaslab .crw or .raw data loader, also populates self.dig_header</span>

<span class="sd">        Similar to MATLAB erpio2</span>
<span class="sd">   </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eeg_f : str</span>
<span class="sd">           path to .crw or .raw data file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        channel_names, raw_evcodes, record_counts, eeg, dig_header : tuple</span>

<span class="sd">        channel_names : list of str</span>
<span class="sd">           labels of EEG data channels in order from the .crw/.raw data header</span>
<span class="sd">        raw_evcodes : 1-D array of int</span>
<span class="sd">           event codes from mark track in each record</span>
<span class="sd">        record_counts : int</span>
<span class="sd">           number of 256-sample A/D data records as read from eeg_f</span>
<span class="sd">        eeg : np.ndarray (shape = (record_counts * 256, 1 + len(channel_names)</span>
<span class="sd">           array of A/D values knit together from the data records of</span>
<span class="sd">           256 samples each, for the event mark track and channels</span>
<span class="sd">        dig_header : dict</span>
<span class="sd">           key: values from the .crw/.raw header + some extra metadata</span>


<span class="sd">        * Pausing makes kutaslab &quot;continuous&quot; EEG data gappy. However,</span>
<span class="sd">          since the dig clock ticks stop during a pause,  ticks are</span>
<span class="sd">          not sample counts (at a fixed rate) not real-time clock ticks. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># slurp low level NJS data</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">eeg_f</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fr</span><span class="p">:</span>
            <span class="n">channel_names</span><span class="p">,</span> <span class="n">raw_evcodes</span><span class="p">,</span> <span class="n">record_counts</span><span class="p">,</span> <span class="n">eeg</span><span class="p">,</span> <span class="n">dig_header</span> <span class="o">=</span> <span class="n">mkio</span><span class="o">.</span><span class="n">read_raw</span><span class="p">(</span>
                <span class="n">fr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int16&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">channel_names</span><span class="p">,</span> <span class="n">raw_evcodes</span><span class="p">,</span> <span class="n">record_counts</span><span class="p">,</span> <span class="n">eeg</span><span class="p">,</span> <span class="n">dig_header</span>

    <span class="k">def</span> <span class="nf">_check_mkh5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;error check structure and contents of self.eeg&quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s2">&quot;FIX ME: code predates from mkh5 data format&quot;</span><span class="p">)</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># eeg</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eeg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># fugedaboutit</span>
            <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eeg data&quot;</span><span class="p">))</span>

        <span class="c1"># FIX ME check the data has the right shape</span>

        <span class="c1"># check for data errors in crw/raw</span>
        <span class="n">max_chunk</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dig_chunks</span><span class="p">[</span><span class="s2">&quot;dig_chunks&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dig_chunks</span><span class="p">[</span><span class="s2">&quot;dig_chunks&quot;</span><span class="p">]</span>
            <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_chunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">256</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> eeg dig records are not sequential, file may be corrupted: </span><span class="si">{1}</span><span class="s2">&quot;</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="n">errmsg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dig_header</span><span class="p">[</span><span class="s2">&quot;eegfile&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dig_chunks</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">DigRecordsNotSequential</span><span class="p">)</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># dig_header</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="n">important_keys</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;subdesc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;samplerate&quot;</span><span class="p">,</span>
            <span class="s2">&quot;expdesc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;nchans&quot;</span><span class="p">,</span>
            <span class="s2">&quot;magic&quot;</span><span class="p">,</span>
            <span class="s2">&quot;recordsize&quot;</span><span class="p">,</span>
            <span class="s2">&quot;odelay&quot;</span><span class="p">,</span>
            <span class="s2">&quot;recordduration&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dig_file_md5&quot;</span><span class="p">,</span>
            <span class="s2">&quot;dig_file&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="c1"># FIX ME: check the important keys have sensible values</span>
        <span class="c1"># fail on missing important keys and values</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">important_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dig_header</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dig_header key </span><span class="si">{0}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_dig_header</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dig_header</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="s2">&quot;&quot;</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dig_header </span><span class="si">{0}</span><span class="s2"> value not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)))</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># location information if present, must be well behaved</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># if &#39;yhdr&#39; in vars(self):</span>
        <span class="c1">#     # fail on duplicate electrode labels</span>
        <span class="c1">#     ll = [x.label for x in self.yhdr[&#39;sensors&#39;]]</span>
        <span class="c1">#     if not all(np.sort(ll) == np.sort(np.unique(ll))):</span>
        <span class="c1">#         raise(DuplicateLocationLabelError)</span>

        <span class="c1"># FIX ME: fail on missing location info any channel</span>

    <span class="k">def</span> <span class="nf">_h5_update_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5_dblock</span><span class="p">,</span> <span class="n">slash_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        add/overwrite dblock header info via dpath slashpath accessors</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        h5_dblock : (reference to h5py dataset in open, writeable mkh5 file)</span>
<span class="sd">          slash_vals a 2-pl (slash_path, value) or list of them, each settable by dpath.util.set</span>
<span class="sd">          kwargs ... keywords past to dpath.util.set</span>

<span class="sd">        Ex.  _h5_set_dblock_attr(h5dblock, (S01/dblock_0/samplerate, 250))</span>
<span class="sd">        Ex.  _h5_set_dblock_attr(h5dblock, [ (S01/dblock_0/streams/lle/calibrated, True), </span>
<span class="sd">                                             (S01/dblock_0/streams/lhz/calibrated, True) ])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># promote singleton tuple to a list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slash_vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">slash_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">slash_vals</span><span class="p">]</span>
        <span class="n">hio</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
        <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">h5_dblock</span><span class="p">)</span>
        <span class="n">hio</span><span class="o">.</span><span class="n">_update_from_slashpaths</span><span class="p">(</span><span class="n">slash_vals</span><span class="p">)</span>
        <span class="n">hio</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">h5_dblock</span><span class="p">)</span>  <span class="c1"># push header back into the dblock</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># dimension conversions samples &lt;--&gt; ms</span>
    <span class="c1"># ------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_ms2samp</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">srate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;convert (non-negative) ms intervals to samples&quot;&quot;&quot;</span>
        <span class="n">period</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="n">srate</span>
        <span class="n">samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ms</span> <span class="o">/</span> <span class="n">period</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">samp</span>

    <span class="k">def</span> <span class="nf">_samp2ms</span><span class="p">(</span><span class="n">samp</span><span class="p">,</span> <span class="n">srate</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;convert n samples to ms at sample rate&quot;&quot;&quot;</span>
        <span class="n">period</span> <span class="o">=</span> <span class="mf">1000.0</span> <span class="o">/</span> <span class="n">srate</span>  <span class="c1"># in ms</span>
        <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">samp</span> <span class="o">*</span> <span class="n">period</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ms</span>

    <span class="k">def</span> <span class="nf">_get_dblock_slices_at</span><span class="p">(</span>
        <span class="n">anchors</span><span class="p">,</span> <span class="n">n_before</span><span class="p">,</span> <span class="n">n_duration</span><span class="p">,</span> <span class="n">min_samp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_samp</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns an array of slice tuples (start_sample, anchor, stop_sample)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        anchors : nd.array, shape (n, )</span>
<span class="sd">            non-negative sample counters, e.g., 0, 27, 30004</span>
<span class="sd">        n_before: uint</span>
<span class="sd">            the number of samples before the anchor (positive integer)</span>
<span class="sd">        n_duration : uint</span>
<span class="sd">           epoch slice length in samples (positive integer) </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : numpy.ndarray, dtype=mkh5._dblock_slicer_dtype       </span>
<span class="sd">            each dblock_slicer is a tuple of sample indices</span>
<span class="sd">            (start_idx, anchor_idx, stop_idx)</span>
<span class="sd">        </span>

<span class="sd">        This just does the sample math the sample math, minimal bounds checking</span>
<span class="sd">        </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_ticks</span> <span class="o">=</span> <span class="n">anchors</span> <span class="o">-</span> <span class="n">n_before</span>  <span class="c1"># *subtract* positive numbers</span>
        <span class="n">stop_ticks</span> <span class="o">=</span> <span class="n">start_ticks</span> <span class="o">+</span> <span class="n">n_duration</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">epochs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start_ticks</span><span class="p">,</span> <span class="n">anchors</span><span class="p">,</span> <span class="n">stop_ticks</span><span class="p">)],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_dblock_slicer_dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># check bounds</span>
        <span class="k">if</span> <span class="n">min_samp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">min_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_epoch_t</span><span class="p">)</span><span class="o">.</span><span class="n">min</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">epochs</span><span class="p">[</span><span class="s2">&quot;start_samps&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_samp</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;epoch starting sample is less than min_samp </span><span class="si">{0}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;... bad anchors or presampling?&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_samp</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_samp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_epoch_t</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">epochs</span><span class="p">[</span><span class="s2">&quot;stop_samps&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_samp</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;epoch starting sample is greater than than </span><span class="si">{0}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;... bad anchors or duration?&quot;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_samp</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">epochs</span>

    <span class="k">def</span> <span class="nf">_get_dblock_slicer_from_eventstream</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">event_stream</span><span class="p">,</span> <span class="n">presamp</span><span class="p">,</span> <span class="n">duration</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns np.array of _dblock_slicer_dtype for non-zero events in event_stream</span>
<span class="sd">    </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        event_stream : 1-D array</span>
<span class="sd">            mostly 0&#39;s where non-zero values are taken to be event codes </span>
<span class="sd">        presamp : uin64</span>
<span class="sd">            number of samples before the anchor event (positive number)</span>
<span class="sd">        duration : uint64</span>
<span class="sd">            number of samples in the slice </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">           slices : array of slices,   slice fails: array of slices</span>


<span class="sd">        Designed for use with dblock_N[&#39;log_evcodes&#39;] data streams</span>
<span class="sd">        though will work with arbitrary 1-D array &quot;event_streams&quot;.</span>
<span class="sd">        This allows programmatic construction of event stream.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># find non-zero event codes in the event_stream</span>
        <span class="n">event_ticks</span> <span class="o">=</span> <span class="p">(</span><span class="n">event_stream</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">slices</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_get_dblock_slices_at</span><span class="p">(</span><span class="n">event_ticks</span><span class="p">,</span> <span class="n">presamp</span><span class="p">,</span> <span class="n">duration</span><span class="p">)</span>
        <span class="n">inbounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">slices</span><span class="p">[</span><span class="s2">&quot;start_samps&quot;</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="n">slices</span><span class="p">[</span><span class="s2">&quot;stop_samps&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_stream</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">slice_fails</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="n">inbounds</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span>  <span class="c1"># slice out bad</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="n">inbounds</span> <span class="o">==</span> <span class="kc">True</span><span class="p">]</span>  <span class="c1"># and drop them</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">slices</span><span class="p">,</span> <span class="n">slice_fails</span><span class="p">)</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># Model: data handling</span>
    <span class="c1"># ------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_read_raw_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eeg_f</span><span class="p">,</span> <span class="n">log_f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;slurp, merge, and return the log and raw as typed np.ndarray plus</span>
<span class="sd">        header dict</span>

<span class="sd">        NJS crw/log slurpers plus TPU decorations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        eeg_f : str</span>
<span class="sd">           path to ERPSS .crw or .raw file</span>
<span class="sd">        log_f : str</span>
<span class="sd">           path to ERPSS .log file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log and raw in single np.ndarray</span>



<span class="sd">        Each dig record contains 256 sweeps == samples == ticks. Within a</span>
<span class="sd">        record, each sweep is a  clock tick by definition. The records in</span>
<span class="sd">        sequence comprise all the sweeps and provides. </span>

<span class="sd">        .. TO DO: some day patch mkio to yield rather than copy eeg</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load crw</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">eeg_f</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fr</span><span class="p">:</span>
            <span class="n">channel_names</span><span class="p">,</span> <span class="n">raw_evcodes</span><span class="p">,</span> <span class="n">record_counts</span><span class="p">,</span> <span class="n">eeg</span><span class="p">,</span> <span class="n">dig_header</span> <span class="o">=</span> <span class="n">mkio</span><span class="o">.</span><span class="n">read_raw</span><span class="p">(</span>
                <span class="n">fr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int16&quot;</span>
            <span class="p">)</span>
        <span class="n">n_ticks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_evcodes</span><span class="p">)</span>  <span class="c1"># eeg.shape[0]</span>

        <span class="c1"># load log, screen out 0&#39;s and codes at ticks beyond data fringe</span>
        <span class="n">tmp_log</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">log_f</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">tick</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">mkio</span><span class="o">.</span><span class="n">read_log</span><span class="p">(</span><span class="n">fid</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n_ticks</span> <span class="o">&lt;=</span> <span class="n">tick</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;uh oh ... log has events beyond the raw data.&quot;</span>
                        <span class="s2">&quot; Check raw vs log for discrepancies or else.&quot;</span>
                        <span class="s2">&quot; Discarding these log events as out of bounds: &quot;</span>
                    <span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">LogRawEventCodeMismatch</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;Trimming illegal log event code 0 at clock tick </span><span class="si">{0}</span><span class="s2">. &quot;</span>
                        <span class="s2">&quot;Make sure you know how it got there&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># non-zero code, in bounds so add to the list</span>
                    <span class="n">tmp_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">code</span><span class="p">,</span> <span class="n">tick</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">flag</span><span class="p">))</span>

        <span class="c1"># compare screened log event codes with raw event codes</span>
        <span class="n">raw_events</span> <span class="o">=</span> <span class="n">raw_evcodes</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">raw_evcodes</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">n_raw_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">raw_events</span><span class="p">)</span>
        <span class="n">n_log_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_log</span><span class="p">)</span>

        <span class="c1"># not enough log codes is fatal. raw does not have ccodes</span>
        <span class="c1"># needed for calibration.</span>
        <span class="k">if</span> <span class="n">n_log_events</span> <span class="o">&lt;</span> <span class="n">n_raw_events</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;uh oh ... fewer events in the log than raw. &quot;</span>
                <span class="s2">&quot;To use mkpy.mkh5 you must rebuild a valid log&quot;</span>
                <span class="s2">&quot;from a raw2asci -events dump then asci2log. &quot;</span>
                <span class="s2">&quot;To simply load raw data use mkpy.mkio.read_raw()&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="c1"># to get here we have the same number of raw and log event</span>
        <span class="c1"># codes at the same ticks though the codes may be different</span>
        <span class="k">assert</span> <span class="n">n_raw_events</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_log</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">raw_evcodes</span><span class="p">[</span><span class="n">tick</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">tick</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tmp_log</span><span class="p">])</span>

        <span class="c1"># # too many log codes is merely dangerous ...</span>
        <span class="c1"># if n_log_events &gt; n_raw_events:</span>
        <span class="c1">#     msg = (&#39;careful ... more events in the log than raw. The raw may be truncated &#39;</span>
        <span class="c1">#            &#39;at the end and/or pathologically misaligned. Figure out which.&#39;)</span>
        <span class="c1">#     warnings.warn(msg, LogRawEventCodeMismatch)</span>

        <span class="c1"># # 1. check log &lt;-&gt; raw event code consistency</span>
        <span class="c1"># for i,(code, tick, condition, flag) in enumerate(tmp_log):</span>

        <span class="c1">#     #  find some non-zero event code or other at the log clock or die</span>
        <span class="c1">#     if raw_evcodes[tick] == 0:</span>
        <span class="c1">#         msg = ((&#39;mismatch raw sample {0} event code {1}: log sample {2}&#39;</span>
        <span class="c1">#                 &#39; event code {3}&#39;).format(i, raw_evcodes[i], tick, code))</span>
        <span class="c1">#         raise ValueError(msg)</span>

        <span class="c1">#     # warn if it is a mismatch ... could be logpoked or serious error</span>
        <span class="c1">#     if code != raw_evcodes[tick]:</span>
        <span class="c1">#         msg = ((&#39;mismatch at raw sample {0} event code {1}: log sample {2}&#39;</span>
        <span class="c1">#                 &#39; event code {3}&#39;).format(i, raw_evcodes[i], tick, code))</span>
        <span class="c1">#         warnings.warn(msg, LogRawEventCodeMismatch)</span>

        <span class="c1"># build datablocks in earnest</span>

        <span class="c1"># tick and log info stream dtypes</span>
        <span class="n">dt_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;dblock_ticks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;crw_ticks&quot;</span><span class="p">,</span>
            <span class="s2">&quot;raw_evcodes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_evcodes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_ccodes&quot;</span><span class="p">,</span>
            <span class="s2">&quot;log_flags&quot;</span><span class="p">,</span>
            <span class="s2">&quot;pygarv&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">dt_formats</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_evtick</span><span class="p">,</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_evtick</span><span class="p">,</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_evcode</span><span class="p">,</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_evcode</span><span class="p">,</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_log_ccode</span><span class="p">,</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_log_flag</span><span class="p">,</span>
            <span class="n">mkh5</span><span class="o">.</span><span class="n">_pygarv</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">dt_titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;t_</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">dt_names</span><span class="p">]</span>

        <span class="c1"># eeg stream dtypes</span>
        <span class="n">dt_names</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">])</span>
        <span class="n">dt_formats</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_mk_EEG</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">channel_names</span><span class="p">)))</span>
        <span class="n">dt_titles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;dig_chan_</span><span class="si">{0:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="c1"># mkh5 dblock dtype</span>
        <span class="n">dt_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="n">dt_names</span><span class="p">,</span> <span class="s2">&quot;formats&quot;</span><span class="p">:</span> <span class="n">dt_formats</span><span class="p">,</span> <span class="s2">&quot;titles&quot;</span><span class="p">:</span> <span class="n">dt_titles</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># load eeg streams and build the crw_tick index</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">raw_evcodes</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_data</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;crw_ticks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_ticks</span><span class="p">)</span>
        <span class="c1"># data[&#39;crw_ticks&#39;] = np.arange(len(raw_evcodes))</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;raw_evcodes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">raw_evcodes</span>

        <span class="c1"># load the .log streams</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">tick</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tmp_log</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">][</span><span class="n">tick</span><span class="p">]</span> <span class="o">=</span> <span class="n">code</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">][</span><span class="n">tick</span><span class="p">]</span> <span class="o">=</span> <span class="n">condition</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;log_flags&quot;</span><span class="p">][</span><span class="n">tick</span><span class="p">]</span> <span class="o">=</span> <span class="n">flag</span>

        <span class="c1"># load eeg stream data</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ch_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_names</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="n">ch_name</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">eeg</span><span class="p">[:,</span> <span class="n">c</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mkh5</span><span class="o">.</span><span class="n">_mk_EEG</span>
            <span class="p">)</span>

        <span class="c1"># capture the new numpy metadata for variable columns</span>
        <span class="c1"># as a sequence to preserve column order</span>
        <span class="c1"># dblock_cols = [] # list version</span>
        <span class="n">dblock_cols</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># dict version</span>
        <span class="k">for</span> <span class="n">col_jdx</span><span class="p">,</span> <span class="n">col_desc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dt_data</span><span class="o">.</span><span class="n">descr</span><span class="p">):</span>
            <span class="n">col_dict</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">col_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;jdx&quot;</span><span class="p">:</span> <span class="n">col_jdx</span><span class="p">,</span>
                <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">col_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">col_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;dt&quot;</span><span class="p">:</span> <span class="n">col_desc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="c1"># &quot;calibrated&quot;: False,  # still raw A/D</span>
                <span class="c1"># &quot;cals&quot;: dict()        #</span>
            <span class="p">}</span>
            <span class="c1"># dblock_cols.append(col_dict) # list version</span>
            <span class="n">dblock_cols</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">col_desc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span> <span class="n">col_dict</span><span class="p">})</span>  <span class="c1"># dict version</span>

        <span class="c1"># FIX ME ... check we don&#39;t clobber dig_head info</span>

        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;streams&quot;</span><span class="p">:</span> <span class="n">dblock_cols</span><span class="p">}</span>
        <span class="c1"># patch np dtypes for jsonification ... ugh</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dig_header</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">):</span>
                <span class="n">attr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf8&quot;</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">):</span>
                <span class="n">attr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># decorate constant columns with more useful info</span>
        <span class="n">attr</span><span class="p">[</span><span class="s2">&quot;eeg_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">eeg_f</span>
        <span class="n">attr</span><span class="p">[</span><span class="s2">&quot;log_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_f</span>
        <span class="n">attr</span><span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">fname</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;eeg_file_md5&quot;</span><span class="p">:</span> <span class="n">eeg_f</span><span class="p">,</span> <span class="s2">&quot;log_file_md5&quot;</span><span class="p">:</span> <span class="n">log_f</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">attr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

        <span class="c1"># New version returns the header and stuff as a dict</span>
        <span class="c1"># jsonification occurs in dblock CRUD</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_h5_get_slices_from_datablock</span><span class="p">(</span><span class="n">dblock</span><span class="p">,</span> <span class="n">slicer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;minimal mkh5 datablock epochs slicer</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        dblock : h5py.Dataset</span>
<span class="sd">            an open, readable mkh5 datablock, dblock_N</span>
<span class="sd">        slicer : numpy.ndarray, dtype=dtype _evticks</span>
<span class="sd">            i.e., tuples (start_samps, anchor_samps, stop_samps), </span>

<span class="sd">        Returns a copy of the data </span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">epochs_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">slicer</span><span class="p">:</span>
            <span class="c1"># dblocks are sample rows down x data columns across</span>
            <span class="c1"># slicing here is a *row* slice, exactly what we want</span>
            <span class="n">epochs_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dblock</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s2">&quot;start_samps&quot;</span><span class="p">]</span> <span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="s2">&quot;stop_samps&quot;</span><span class="p">]])</span>

            <span class="c1"># stack the arrays so access by name, e.g., MiPa returns a</span>
            <span class="c1"># subarray with sample rows down x epoch columns accross</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">epochs_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_h5_get_calinfo</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">h5f</span><span class="p">,</span>
        <span class="n">group_name</span><span class="p">,</span>
        <span class="n">n_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cal_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lo_cursor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hi_cursor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">cal_ccode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;scan mkh5 datablocks under h5_path for cals and return channel-wise AD scaling info</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        h5f : str</span>
<span class="sd">           hdf5 file w/ conforming mkh5 data)group/dblock_N structure</span>
<span class="sd">        group_name : str</span>
<span class="sd">           mkh5 data_group to search for cal events and pulses</span>
<span class="sd">        n_points : uint</span>
<span class="sd">            number of samples average on either side of cursor</span>
<span class="sd">        cal_size : float, units of microvolts</span>
<span class="sd">            size of calibration pulse</span>
<span class="sd">        lo_cursor : float, units of milliseconds</span>
<span class="sd">            center of the pre-pulse window to average in computing the cal pulse amplitude</span>
<span class="sd">        hi_cursor : float, units of milliseconds</span>
<span class="sd">            center of the post-pulse window to average in computing the cal pulse amplitude</span>
<span class="sd">        cal_ccode : uint</span>
<span class="sd">            log condition code designated for calibration pulses, typically 0 by convention</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        dictionary including &#39;scale_by&#39; factor and summary stats on the cals = (None,None) on fail</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if missing kwargs </span>
<span class="sd">        IOError if no kutaslab cals found in any of the group_name dblocks</span>

<span class="sd">        Return values coerced to float b.c. json can&#39;t serialze float16 .. cmon</span>

<span class="sd">        Unopinionated about what h5 group to search and works on any dblock with cals</span>
<span class="sd">        so it can be called on cals recorded with the EEG or in separate files. </span>

<span class="sd">        Differences from normerp:</span>

<span class="sd">          - the pp_uV resolution argument is not used</span>

<span class="sd">          - there is no polarity parameter which has little to no point for data analysis</span>

<span class="sd">          - cal_cc (for condition code) is used instead of cal_bin</span>
<span class="sd">            since the single trial eeg and log files have no bins</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># input check ...</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="n">must_have</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_points</span><span class="p">,</span> <span class="n">cal_size</span><span class="p">,</span> <span class="n">lo_cursor</span><span class="p">,</span> <span class="n">hi_cursor</span><span class="p">,</span> <span class="n">cal_ccode</span><span class="p">]</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">must_have</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;missing keyword arguments ... check for &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;n_points, cal_size, lo_cursor &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;hi_cursor, cal_ccode&quot;</span>
            <span class="p">)</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># scan the group_name datablocks for cals ...</span>
        <span class="c1">#  . cal epoch stacks are snippets of samples surrounding a pulse</span>
        <span class="c1">#  . there can be 1+ if cals are found in different datablocks</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5f</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5</span><span class="p">:</span>

            <span class="c1"># walk the group and gather up datablocks</span>
            <span class="n">group</span> <span class="o">=</span> <span class="n">h5</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
            <span class="n">dblock_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">g</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;dblock&quot;</span> <span class="ow">in</span> <span class="n">g</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="n">g</span><span class="p">],</span> <span class="n">h5py</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dblock_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Mkh5FormatError</span><span class="p">(</span>
                    <span class="s2">&quot;datablocks not found in </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; check the id and/or load data&quot;</span>
                <span class="p">)</span>

            <span class="c1"># holds the calibration epoch stacks across datablocks, normally len == 1</span>
            <span class="n">cal_stacks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cal_dblock_ids</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for reporting only</span>
            <span class="n">srate</span> <span class="o">=</span> <span class="n">nchans</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">hio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">HeaderIO</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">gn</span> <span class="ow">in</span> <span class="n">dblock_sets</span><span class="p">:</span>
                <span class="n">g</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">consts</span><span class="p">,</span> <span class="n">strms</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">gn</span><span class="p">]</span>
                <span class="c1"># json -&gt; dict</span>
                <span class="c1"># attrs = json.loads(g.attrs[&#39;json_attrs&#39;]) # deprecated</span>
                <span class="c1"># old_strms = attrs[&#39;streams&#39;] # deprecated</span>
                <span class="n">hio</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>  <span class="c1"># fetch the dblock header for access</span>
                <span class="n">strms</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;streams&quot;</span><span class="p">]</span>
                <span class="c1"># assert old_strms == strms</span>

                <span class="c1"># scan for calibration events using log_evcodes in case</span>
                <span class="c1"># bad cals have been manually logpoked</span>
                <span class="c1"># if any((g[&#39;log_ccodes&#39;] == cal_ccode) &amp; (g[&#39;log_evcodes&#39;] &lt; 0)):</span>
                <span class="n">neg_cal_events</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">][</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cal_ccode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">neg_cal_events</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;negative event code(s) found for cal condition code &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cal_ccode</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot; &quot;</span>
                    <span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neg_cal_events</span><span class="p">])</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">cal_event_ptrs</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s2">&quot;log_ccodes&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">cal_ccode</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># winner winner chicken dinner ... but horribly procedural</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_event_ptrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># we have a cal block</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found cals in </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="n">cal_dblock_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5f</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                    <span class="p">)</span>  <span class="c1"># log it</span>

                    <span class="c1"># FIX ME: this is rude, we already knew this at dblock_0</span>
                    <span class="c1"># but this way it reports where the cals were found</span>
                    <span class="c1"># is_calibrated = any([&#39;cals&#39; in col.keys() for col in strms if &#39;dig_chan_&#39; in col[&#39;source&#39;] ])</span>
                    <span class="c1"># is_calibrated = any([v for k,v in strms.items() if k == &#39;calibrated&#39;])</span>
                    <span class="n">is_calibrated</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="s2">&quot;cals&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">strms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="k">if</span> <span class="s2">&quot;dig_chan_&quot;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">is_calibrated</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">group_name</span>
                            <span class="o">+</span> <span class="s2">&quot;/&quot;</span>
                            <span class="o">+</span> <span class="n">gn</span>
                            <span class="o">+</span> <span class="s2">&quot; cannot access calibration pulses, they have already been scaled to uV&quot;</span>
                        <span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># check sample rate and channels against the previous block (if any)</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">srate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;samplerate&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">srate</span>
                    <span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;srate in block </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">gn</span><span class="p">,</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;samplerate&quot;</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot;does not match previous data block: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">srate</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nchans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;nchans&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nchans</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;number of channels in block </span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">gn</span><span class="p">,</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;nchans&quot;</span><span class="p">]</span>
                            <span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot;does not match previous data block: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">nchans</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                    <span class="c1"># set params this datablock ...</span>
                    <span class="n">srate</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;samplerate&quot;</span><span class="p">]</span>
                    <span class="n">nchans</span> <span class="o">=</span> <span class="n">hio</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s2">&quot;nchans&quot;</span><span class="p">]</span>

                    <span class="c1"># humans use ms ...</span>
                    <span class="n">lcs</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_ms2samp</span><span class="p">(</span>
                        <span class="n">lo_cursor</span><span class="p">,</span> <span class="n">srate</span>
                    <span class="p">)</span>  <span class="c1"># in negative samples b.c. of normerp incantations</span>
                    <span class="n">hcs</span> <span class="o">=</span> <span class="n">mkh5</span><span class="o">.</span><span class="n">_ms2samp</span><span class="p">(</span><span class="n">hi_cursor</span><span class="p">,</span> <span class="n">srate</span><span class="p">)</span>

                    <span class="c1"># computers use samples ...</span>
                    <span class="n">presamp</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">lcs</span>
                    <span class="p">)</span> <span class="o">+</span> <span class="n">n_points</span>  <span class="c1"># presampling is a magnitude (positive) for epoch calc</span>
                    <span class="n">duration</span> <span class="o">=</span> <span class="n">hcs</span> <span class="o">+</span> <span class="n">n_points</span> <span class="o">+</span> <span class="n">presamp</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="c1"># returns an nd.array, access by data column name</span>
                    <span class="c1"># return subarray: duration samples x epochs</span>
                    <span class="c1"># (cal_slicer, fails) = self._get_dblock_slicer_from_eventstream(g[&#39;raw_evcodes&#39;], presamp, duration)</span>
                    <span class="p">(</span>
                        <span class="n">cal_slicer</span><span class="p">,</span>
                        <span class="n">fails</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dblock_slicer_from_eventstream</span><span class="p">(</span>
                        <span class="n">g</span><span class="p">[</span><span class="s2">&quot;log_evcodes&quot;</span><span class="p">],</span> <span class="n">presamp</span><span class="p">,</span> <span class="n">duration</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fails</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                            <span class="s2">&quot;dropping </span><span class="si">{0}</span><span class="s2"> cal epochs out of data bounds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="nb">len</span><span class="p">(</span><span class="n">fails</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

                    <span class="n">cal_stacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">mkh5</span><span class="o">.</span><span class="n">_h5_get_slices_from_datablock</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">cal_slicer</span><span class="p">)</span>
                    <span class="p">)</span>

            <span class="c1"># typically cals in one dblock tho no harm in more if they are good</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_stacks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="p">(</span>
                    <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="s2">&quot;cal events not found in file </span><span class="si">{0}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h5f</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot;for </span><span class="si">{0}</span><span class="s2"> dblocks and log_ccode </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">group_name</span><span class="p">,</span> <span class="n">cal_ccode</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_stacks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;found </span><span class="si">{0}</span><span class="s2"> datablocks with cal events and using all of them&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">cal_stacks</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot;if this is unexpected check the crw/log and cal files&quot;</span>
                <span class="p">)</span>

            <span class="c1"># combine cal events from the dblocks into one stack,</span>
            <span class="c1"># samples down, events across, each element in sub array</span>
            <span class="c1"># is a row of dblock</span>
            <span class="n">cal_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">cal_stacks</span><span class="p">)</span>

            <span class="c1"># pull the datablock column info down from the attrs/header</span>

            <span class="c1"># colmdat = json.loads(g.attrs[&#39;streams&#39;]) # deprecated</span>
            <span class="c1"># chan_names = [c[&#39;name&#39;] for c in strms if &#39;dig_chan_&#39; in c[&#39;source&#39;]] # list version</span>
            <span class="n">chan_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">c</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">strms</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;dig_chan_&quot;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
            <span class="p">]</span>  <span class="c1"># dict version</span>
            <span class="n">cal_factors</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chan_names</span><span class="p">):</span>
                <span class="c1"># ------------------------------------------------------------</span>
                <span class="c1"># auto trim the data FIX ME ... parameterize configurable someday</span>
                <span class="c1"># ------------------------------------------------------------</span>
                <span class="n">q75</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">q25</span><span class="p">,</span> <span class="n">iqr</span><span class="p">,</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="n">delta_min</span><span class="p">,</span> <span class="n">delta_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="n">deltas</span><span class="p">,</span> <span class="n">good</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

                <span class="c1"># deltas are cal pulse step size (n, ) for n channels</span>

                <span class="c1"># float16 version</span>
                <span class="c1"># deltas = (cal_set[n][-(1+n_points*2):,:] - \</span>
                <span class="c1">#             cal_set[n][:(1+n_points*2),:]).mean(axis=0)</span>

                <span class="c1"># float64 version ... scaling 12-bit AD x 1e5 is safe for float64</span>
                <span class="n">deltas</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">cal_set</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_points</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="p">:,</span> <span class="p">:]</span>
                    <span class="o">-</span> <span class="n">cal_set</span><span class="p">[</span><span class="n">n</span><span class="p">][:</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n_points</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="p">:]</span>
                <span class="p">)</span>
                <span class="n">deltas_e5</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;&lt;f8&quot;</span><span class="p">)</span>
                <span class="n">deltas</span> <span class="o">=</span> <span class="mf">1e-5</span> <span class="o">*</span> <span class="n">deltas_e5</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># trim the deltas</span>
                <span class="n">q75</span><span class="p">,</span> <span class="n">median</span><span class="p">,</span> <span class="n">q25</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="p">[</span><span class="mi">75</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">])</span>
                <span class="n">iqr</span> <span class="o">=</span> <span class="n">q75</span> <span class="o">-</span> <span class="n">q25</span>
                <span class="n">delta_min</span> <span class="o">=</span> <span class="n">median</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">iqr</span><span class="p">)</span>
                <span class="n">delta_max</span> <span class="o">=</span> <span class="n">median</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">iqr</span><span class="p">)</span>
                <span class="n">good</span> <span class="o">=</span> <span class="n">deltas</span><span class="p">[(</span><span class="n">delta_min</span> <span class="o">&lt;</span> <span class="n">deltas</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">deltas</span> <span class="o">&lt;</span> <span class="n">delta_max</span><span class="p">)]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;uh oh ... </span><span class="si">{0}</span><span class="s2"> channel </span><span class="si">{1}</span><span class="s2">:</span><span class="si">{2}</span><span class="s2"> has no cal pulses &quot;</span>
                        <span class="s2">&quot;after trimming at median +/- 1.5IQR&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> channel </span><span class="si">{1}</span><span class="s2">:</span><span class="si">{2}</span><span class="s2"> ... less than half the cal pulses remain &quot;</span>
                        <span class="s2">&quot;after trimming at median +/- 1.5IQR. &quot;</span>
                        <span class="s2">&quot;Do you know why?&quot;</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h5_fname</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="c1"># numpy may leave some as float16 if it can ... makes</span>
                <span class="c1"># json serializer unhappy</span>
                <span class="n">cal_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;n_points&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_points</span><span class="p">),</span>
                        <span class="s2">&quot;cal_size&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cal_size</span><span class="p">),</span>
                        <span class="s2">&quot;lo_cursor&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">lo_cursor</span><span class="p">),</span>
                        <span class="s2">&quot;hi_cursor&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">hi_cursor</span><span class="p">),</span>
                        <span class="s2">&quot;cal_ccode&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">cal_ccode</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">)</span>
                <span class="n">cal_factors</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="n">n</span><span class="p">:</span> <span class="p">{</span>
                            <span class="s2">&quot;cal_srate&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">srate</span><span class="p">),</span>
                            <span class="s2">&quot;cal_dblock&quot;</span><span class="p">:</span> <span class="n">cal_dblock_ids</span><span class="p">,</span>
                            <span class="s2">&quot;cal_args&quot;</span><span class="p">:</span> <span class="n">cal_args</span><span class="p">,</span>
                            <span class="s2">&quot;scale_by&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">mean</span><span class="p">()),</span>
                            <span class="s2">&quot;var&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">good</span><span class="o">.</span><span class="n">var</span><span class="p">()),</span>
                            <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">median</span><span class="p">),</span>
                            <span class="s2">&quot;iqr&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">iqr</span><span class="p">),</span>
                            <span class="s2">&quot;n_cals&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">)),</span>
                            <span class="s2">&quot;n_trimmed&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">good</span><span class="p">),</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cal_factors</span><span class="p">,</span> <span class="n">cal_set</span><span class="p">)</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># end fetch calibration information</span>
        <span class="c1"># ------------------------------------------------------------</span>

    <span class="c1"># ------------------------------------------------------------</span>
    <span class="c1"># View</span>
    <span class="c1"># ------------------------------------------------------------</span>
<div class="viewcode-block" id="mkh5.plotcals"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.mkh5.plotcals">[docs]</a>    <span class="k">def</span> <span class="nf">plotcals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;visualize cal pulses and scaling factors used to convert to</span>
<span class="sd">        microvolts</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">calinfo</span> <span class="o">=</span> <span class="n">cal_stack</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plotting cals&quot;</span><span class="p">)</span>
        <span class="p">(</span><span class="n">calinfo</span><span class="p">,</span> <span class="n">cal_stack</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h5_get_calinfo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">calinfo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">calinfo</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Mkh5CalError</span><span class="p">(</span>
                <span class="s2">&quot;no cals found in &quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="c1"># FIX ME ... legacy vars</span>
        <span class="n">h5f</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">group_name</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># ------------------------------------------------------------</span>
        <span class="c1"># Cal snippets at each channel</span>
        <span class="c1"># ------------------------------------------------------------</span>
        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">calinfo</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">nchans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span>

        <span class="n">n_col</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nchans</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n_col</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">),</span>
            <span class="n">n_col</span><span class="p">,</span>
            <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
            <span class="n">facecolor</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">calcolors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span>

        <span class="c1"># &#39;hi_cursor&#39;: 50.0, &#39;cal_size&#39;: 10.0,</span>
        <span class="c1"># &#39;cal_ccode&#39;: 0, &#39;lo_cursor&#39;: -50.0, &#39;n_points&#39;: 3}</span>

        <span class="c1"># for c in range(nchans):</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch_names</span><span class="p">):</span>
            <span class="n">cinf</span> <span class="o">=</span> <span class="n">calinfo</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
            <span class="n">cal_args</span> <span class="o">=</span> <span class="n">cinf</span><span class="p">[</span><span class="s2">&quot;cal_args&quot;</span><span class="p">]</span>
            <span class="n">srate</span> <span class="o">=</span> <span class="n">cinf</span><span class="p">[</span><span class="s2">&quot;cal_srate&quot;</span><span class="p">]</span>
            <span class="n">n_points</span> <span class="o">=</span> <span class="n">cal_args</span><span class="p">[</span><span class="s2">&quot;n_points&quot;</span><span class="p">]</span>
            <span class="n">lo_cursor</span> <span class="o">=</span> <span class="n">n_points</span>
            <span class="n">hi_cursor</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_stack</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">lo_span</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">lo_cursor</span> <span class="o">-</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">lo_cursor</span> <span class="o">+</span> <span class="n">n_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">hi_span</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">hi_cursor</span> <span class="o">-</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">hi_cursor</span> <span class="o">+</span> <span class="n">n_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># relative to event @ sample 0</span>
            <span class="n">cal_samps</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span>
                <span class="n">lo_cursor</span> <span class="o">-</span> <span class="n">n_points</span><span class="p">,</span> <span class="n">lo_cursor</span> <span class="o">-</span> <span class="n">n_points</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cal_stack</span><span class="p">[</span><span class="n">ch</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="n">n_col</span><span class="p">),</span> <span class="n">c</span> <span class="o">%</span> <span class="n">n_col</span><span class="p">]</span>
            <span class="c1"># a.set_axis_bgcolor(&#39;k&#39;)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span>
                <span class="n">ch</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
            <span class="p">)</span>

            <span class="c1"># box the points averaged</span>
            <span class="n">a</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                <span class="n">lo_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lo_span</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span>
            <span class="p">)</span>  <span class="c1"># ymax=0.5,</span>
            <span class="n">a</span><span class="o">.</span><span class="n">axvspan</span><span class="p">(</span>
                <span class="n">hi_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hi_span</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span>
            <span class="p">)</span>  <span class="c1"># ymax=0.5,</span>
            <span class="c1"># mark the cursors</span>
            <span class="n">a</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">lo_cursor</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">hi_cursor</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="n">lpc</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">cal_samps</span><span class="p">,</span> <span class="n">cal_stack</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="s2">&quot;.-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">calcolors</span><span class="p">[</span><span class="n">c</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">f</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;calibration pulses from: &quot;</span>
            <span class="n">f</span><span class="s2">&quot;{&#39; &#39;.join([str(arg) for arg in args])}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">f</span><span class="s2">&quot;{&#39; &#39;.join([k + &#39;=&#39; + str(v) for k, v in kwargs.items()])}&quot;</span>
        <span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;lightgray&quot;</span><span class="p">)</span>
        <span class="c1"># plt.show()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span></div></div>


<span class="c1"># TPU</span>
<div class="viewcode-block" id="LocDat"><a class="viewcode-back" href="../../source/mkpy.mkh5.html#mkpy.mkh5.LocDat">[docs]</a><span class="k">class</span> <span class="nc">LocDat</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;map Kutas lab spherical coordinates and Brainsight</span>
<span class="sd">    .elp data files to 3-D cartesian XYZ </span>


<span class="sd">    Coordinates</span>

<span class="sd">       LocDat native positions are in Cartesian 3-space</span>

<span class="sd">       Origin is center of head</span>

<span class="sd">       Orientation is RAS: X+ = Right, Y+ = Anterior, Z+ = Superior</span>
<span class="sd">    </span>
<span class="sd">       Cartesian coordinates come in as triples: x, y, z</span>

<span class="sd">       Polar coordinates come in as triples: radius, theta, z</span>

<span class="sd">    Kutaslab</span>

<span class="sd">       Kutaslab topo coordinates are spherical come in as radius, theta, phi</span>
<span class="sd">       triples (see topofiles for theta, phi) and get mapped to x,y,z</span>

<span class="sd">       * origin is between the ears (co-planar with 10-20 temporal line)</span>

<span class="sd">       * vectors from the origin at angles (degrees)</span>

<span class="sd">          * theta = 0 points toward right ear, along interaural line,</span>
<span class="sd">            90 points to forehead along midline</span>

<span class="sd">          * phi = 0 points to the vertex, 90 points to the temporal line</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">distance_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angle_units</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;initialize LocDat</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        type: str (electrode, fiducial, scalp, ...)</span>

<span class="sd">        label: str (lle, MiPa, Fz, Nasion, scalp37, ...)</span>

<span class="sd">        coord: str (cartesian | polar)</span>

<span class="sd">        pos: array of float, [x, y  z] | radius, theta, phi)</span>
<span class="sd">           See details</span>

<span class="sd">        distance_units: str (cm | inch)</span>

<span class="sd">        angle_units: str (deg | rad)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check arguments ... sort of</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="k">assert</span> <span class="n">distance_units</span>

        <span class="c1"># capture positional arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">coord</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_units</span> <span class="o">=</span> <span class="n">distance_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_units</span> <span class="o">=</span> <span class="n">angle_units</span>

        <span class="c1"># capture cartesian option</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="o">==</span> <span class="s2">&quot;cartesian&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">coord</span> <span class="o">==</span> <span class="s2">&quot;polar&quot;</span><span class="p">:</span>
            <span class="c1"># insist on sensible angle_units for polar coordinates</span>
            <span class="k">assert</span> <span class="n">angle_units</span> <span class="o">==</span> <span class="s2">&quot;degrees&quot;</span> <span class="ow">or</span> <span class="n">angle_units</span> <span class="o">==</span> <span class="s2">&quot;radians&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_units</span> <span class="o">==</span> <span class="s2">&quot;degrees&quot;</span><span class="p">:</span>
                <span class="n">toradians</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="mf">360.0</span>  <span class="c1"># conversion factor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_in_radians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">*</span> <span class="n">toradians</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi_in_radians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span> <span class="o">*</span> <span class="n">toradians</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta_in_radians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi_in_radians</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span>

            <span class="c1"># p projects onto x-y given phi,</span>
            <span class="c1"># so p == 1.0 at phi == 90 and &lt; 1 otherwise</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_in_radians</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_in_radians</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta_in_radians</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_in_radians</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019 Thomas P. Urbach, Andrey Portnoy, 2013 Nathaniel Smith

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>